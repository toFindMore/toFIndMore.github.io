{"posts":[{"title":"【数学】模板 - 矩阵快速幂","content":"大家都知道 Fibonacci 数列吧，f1=1,f2=1,f3=2,f4=3,…,fn=fn−1+fn−2 现在问题很简单，输入 n 和 m，求 fn 的前 n 项和 Sn%m。 输入格式 共一行，包含两个整数 n 和 m。 输出格式 输出前 nn 项和 Sn%m 的值。 数据范围 1≤n≤2000000000 1≤m≤1000000010 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 3; int n, mod; // 实现矩阵乘法 vector&lt;vector&lt;LL&gt;&gt; mul(vector&lt;vector&lt;LL&gt;&gt;&amp; a, vector&lt;vector&lt;LL&gt;&gt;&amp; b){ int n = a.size(); int m = b[0].size(); int t = b.size(); vector&lt;vector&lt;LL&gt;&gt; c(n, vector&lt;LL&gt;(m, 0)); for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ for(int k = 0; k &lt; t; k++){ c[i][j] = (c[i][j] + a[i][k] * b[k][j] % mod) % mod; } } } return c; } // 矩阵快速幂 vector&lt;vector&lt;LL&gt;&gt; qmi(vector&lt;vector&lt;LL&gt;&gt;&amp; a, LL k){ // 单位矩阵I vector&lt;vector&lt;LL&gt;&gt; I{{1, 0, 0}, {0, 1, 0}, {0, 0, 1} }; while(k){ if(k &amp; 1) I = mul(I, a); a = mul(a, a); k &gt;&gt;= 1; } return I; } int main() { cin &gt;&gt; n &gt;&gt; mod; if(n == 1 || n == 2) return 1 % mod; n -= 2; vector&lt;vector&lt;LL&gt;&gt; A {{1, 0, 0}, {1, 1, 1}, {1, 1, 0}}; vector&lt;vector&lt;LL&gt;&gt; ans = qmi(A, n); cout &lt;&lt; (2 * ans[0][0] + ans[1][0] + ans[2][0]) % mod &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/shu-xue-mo-ban-ju-zhen-kuai-su-mi/"},{"title":"【图论】二分图匹配","content":"1. 二分图定义 如果一张无向图的 N 个节点（N&gt;=2N &gt;= 2N&gt;=2）可以分成A、B 两个非空集合，其中 A∩B=∅A \\cap B = \\emptysetA∩B=∅，并且在同一个集合内的点之间没有边相连，那么称这张无向图为二分图。A、B分别称为二分图的左部和右部。 2. 二分图判定 定理：一张无向图是二分图，当且仅当图中不存在奇环。 我们可以根据该定理，使用染色法进行二分图的判定。即刚开始所有点都是没有被染色的，dfs遍历图，如果边的两个点都没有被染色，则指定某个点染色为1， 另一个是2；如果边点两点有一条被染色为 k，则另一个未被染色的边即为 3-k；如果两个点都被染色，如果两个点的染色颜色相同，则该图不是二分图，否则就是二分图。 代码实现如下 bool dfs(int u, int cor) { color[u] = cor; for(int i=h[u];~i;i=ne[i]) { int b = e[i]; if(!color[b]) { dfs(b, 3 - cor); } else { if(color[b] == cor) return false; } } return true; } 3. 二分图最大匹配 任意两条边都没有公共端点 的边的集合被称为图的一组匹配。在二分图中，包含边数最多的一组匹配被称为二分图的最大匹配。 那么如何求二分图（无边权）的最大匹配呢？ 匈牙利算法：这是一种贪心的思路，实现过程就是遍历所有的左部点，去和右部进行匹配， 对于左部点，遍历其边，如果存在右部点未匹配或者右部点匹配点可以找到其他的左部点， 则匹配成功，否则匹配失败。 具体代码实现如下 ： bool vis[N * N]; int match[N * N]; bool find(int u) { // 遍历边 for(int i=h[u];~i;i=ne[i]) { int j = e[i]; // 如果该点已被指派过，则跳过 if(vis[j]) continue; vis[j] = true; // 如果存在右部点未匹配或者右部点匹配点可以找到其他的左部点 if(match[j] == -1 || find(match[j])) { match[j] = u; return true; } } // 匹配失败 return false; } int main() { memset(match, -1, sizeof match); int ans = 0; for(int i=1;i&lt;=n;i++) { // 清空 vis memset(vis, false, sizeof vis); if(find(i)) ans ++; } return 0; } 4. 二分图覆盖与独立集 二分图最小点覆盖：给定一张二分图，求出一个最小的点集 S，使得图中任意一条边都有至少一个端点属于 S，这个问题被称为二分图的最小点覆盖，简称最小覆盖。 可以使用Konig 定义证明： 二分图最小点覆盖包含的点数等于二分图最大匹配包含的边数。 二分图最大独立集：任意两点之间没有边相连的点集是独立集，包含点数最多的一个就是图的最大独立集。 有以下关系：设G是由 n 个节点的二分图，G 的最大独立集的大小等于 n - 最大匹配数。 二分图最小路径点覆盖 有向无环图 G 是的最小路径点覆盖包含的路径条数，等于 n 减去拆点二分图 G2 的最大匹配数。 5. 带权最大匹配 （KM算法） // TODO 6. 网络流 // TODO 7. 题目集 AcWing 257. 关押罪犯 AcWing 372. 棋盘覆盖 AcWing 376. 机器任务 AcWing 378. 骑士放置 AcWing 379. 捉迷藏 ","link":"https://tofindmore.github.io/post/er-fen-tu-pi-pei/"},{"title":"【数据结构】字符串哈希","content":"1 介绍与基础实现 字符串哈希就是把一个任意长度的字符串映射成一个非负整数，并且冲突概率几乎为0。KMP 相比于该方法，除了在计算字符串循环节时候有优势，这个方法完爆KMP。 如何做：取一个固定值 P （经验来说通常取 131 和 13331， 此时概率极低），把字符串看作是 P 进制数， 取一个固定值 M， 改 P 进制数对 M 取余，就是改字符串的HASH值。 如果HASH值相等，通常可以认为两个串是相等的。通常 M 取 2642^{64}264, 可以直接用 unsigned long long 来存储这个HASH 值，在计算的时候不处理算数溢出的问题，因为对于 unsigned 数值，溢出的时候相当于对 2642^{64}264 取模，这样就可以避免低效的取模运算了。 假设我们已经算出了字符串的前缀哈希值，第 i 位记为 h(i)h(i)h(i)，我们就可以计算一个子串的HASH值，下图是证明(计算 l,rl, rl,r 子串的HASH值)： 已知 ：h(i)=s(1)∗Pi−1+s(2)∗Pi−2+...+s(i)∗P0h(i) = s(1) * P^{i-1} + s(2) * P^{i-2} + ... + s(i) * P^0h(i)=s(1)∗Pi−1+s(2)∗Pi−2+...+s(i)∗P0 对于 l−1l-1l−1的串: h(l−1)=s(1)∗Pl−2+s(2)∗Pl−3+...+s(l−1)∗P0h(l-1) = s(1) * P^{l-2} + s(2) * P^{l-3} + ... + s(l-1) * P^0h(l−1)=s(1)∗Pl−2+s(2)∗Pl−3+...+s(l−1)∗P0 对于 rrr 的串: h(r)=s(1)∗Pr−1+s(2)∗Pr−2+...+s(r)∗P0h(r) = s(1) * P^{r-1} + s(2) * P^{r-2} + ... + s(r) * P^0h(r)=s(1)∗Pr−1+s(2)∗Pr−2+...+s(r)∗P0 那么 [l,r][l,r][l,r] 的串的 HASH 值为 h(r)−h(l−1)∗Pr−l+1h(r) - h(l-1) * P^{r-l+1}h(r)−h(l−1)∗Pr−l+1 下面是代码实现： typedef unsigned long long ULL; const int N = 1e5 + 10; // 一般取 131 、13331 const int P = 131; // p[i] 代表 p的i次方 // h[i] 代表前 i 个字符的HASH值 ULL p[N], h[N]; // 实现 ULL get(int l, int r) { return h[r] - h[l-1] * p[r-l+1]; } // 算出前缀HASH值 void build(string s) { // p^0 = 1 p[0] = 1; for(int i=1;i&lt;=n;i++) { p[i] = p[i-1] * P; h[i] = h[i-1] * P + s[i-1]; } } int main() { cin &gt;&gt; s; build(s); int l1, r1, l2, r2; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; cout &lt;&lt; get(l1, r1) == get(l2, r2); return 0; } 2 例题实现 1. 兔子与兔子 很久很久以前，森林里住着一群兔子。 有一天，兔子们想要研究自己的 DNA 序列。 我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 26 个小写英文字母）。 然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。 注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。 输入格式 第一行输入一个 DNA 字符串 S。 第二行一个数字 m，表示 m 次询问。 接下来 m 行，每行四个数字 l1,r1,l2,r2，分别表示此次询问的两个区间，注意字符串的位置从 1 开始编号。 输出格式 对于每次询问，输出一行表示结果。 如果两只兔子完全相同输出 Yes，否则输出 No（注意大小写）。 数据范围 1≤length(S),m≤1000000 输入样例： aabbaabb 3 1 3 5 7 1 3 6 8 1 2 1 2 输出样例： Yes No Yes 代码实现 分析 ： 很明显，这题就是字符串hash裸题，直接用上方的模板就好了。 #include &lt;iostream&gt; using namespace std; typedef unsigned long long ULL; const int N = 1e6 + 10, P = 131; ULL p[N], h[N]; void build(string s) { p[0] = 1; for(int i=1;i&lt;=s.size();i++) { p[i] = p[i-1] * P; h[i] = h[i-1] * P + s[i-1]; } } ULL get(int l, int r) { return h[r] - h[l-1] * p[r - l + 1]; } int main() { string s; cin &gt;&gt; s; build(s); int m; cin &gt;&gt; m; while(m--) { int l1, r1, l2, r2; scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2); if(get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0; } 2.回文子串的最大长度 如果一个字符串正着读和倒着读是一样的，则称它是回文的。 给定一个长度为 N 的字符串 S，求他的最长回文子串的长度是多少。 输入格式 输入将包含最多 30 个测试用例，每个测试用例占一行，以最多 1000000 个小写字符的形式给出。 输入以一个以字符串 END 开头的行表示输入终止。 输出格式 对于输入中的每个测试用例，输出测试用例编号和最大回文子串的长度（参考样例格式）。 每个输出占一行。 输入样例： abcbabcbabcba abacacbaaaab END 输出样例： Case 1: 13 Case 2: 6 代码实现 分析：这题字符串太长区间DP空间爆炸，可以使用马拉车算法求解，这里介绍的主要是 二分 + 字符串HASH 的方法 对于二分 ：我们要将 奇数串 与 偶数串 分开二分（这个很重要） 对于字符串HASH ：我们只需要维护字符串正 h1、反 h2 数组即可，对于回文来讲，正反都一样 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e6 + 10, P = 131; #define Debug(in) cout&lt;&lt;#in&lt;&lt;&quot;=&quot;&lt;&lt;(in)&lt;&lt;endl typedef unsigned long long ULL; int n; ULL p[N], h[N], h_rev[N]; void build(string s) { p[0] = 1; h[0] = 0, h_rev[s.size() + 1] = 0; for(int i=1;i&lt;=s.size();i++) { p[i] = p[i-1] * P; h[i] = h[i-1] * P + s[i-1]; } for(int i=s.size();i&gt;=1;i--) { h_rev[i] = h_rev[i+1] * P + s[i-1]; } } ULL get(int l, int r) { return h[r] - h[l-1] * p[r - l + 1]; } ULL get_rev(int l, int r) { return h_rev[l] - h_rev[r+1] * p[r-l + 1]; } bool find(int sz) { // Debug(sz); if(sz == 1) return true; for(int i=1;i&lt;=n;i++) { int l = i, r = i + sz - 1; if(r &gt; n) break; if(get(l, r) == get_rev(l, r)) { return true; } } return false; } int main() { string s; int caseNum = 0; vector&lt;int&gt; odds; vector&lt;int&gt; evens; for(int i=1;i&lt;N;i++) { if(i &amp; 1) odds.push_back(i); else evens.push_back(i); } while(cin &gt;&gt; s, s != &quot;END&quot;) { build(s); int ans = 1; n = s.size(); int k; // odd if(n &amp; 1) k = n; else k = n - 1; int l = 0, r = lower_bound(odds.begin(), odds.end(), k) - odds.begin(); while(l&lt;=r) { int mid = (l + r) &gt;&gt; 1; bool b = find(odds[mid]); if(b) ans = max(ans, odds[mid]), l = mid + 1; else r = mid - 1; } // even if(n &amp; 1) k = n - 1; else k = n; l = 0, r = lower_bound(evens.begin(), evens.end(), k) - evens.begin(); while(l&lt;=r) { int mid = (l + r) &gt;&gt; 1; bool b = find(evens[mid]); if(b) ans = max(ans, evens[mid]), l = mid + 1; else r = mid - 1; } printf(&quot;Case %d: %d\\n&quot;, ++caseNum, ans); } return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-zi-fu-chuan-ha-xi/"},{"title":"【数学知识】 质数与约数（线性筛、欧几里得、扩展欧几里得）","content":"质数 试除法，判定n是否是质数，时间复杂度 O(N*SQRT(N)) // 就是一个2到sqrt(n)的遍历 bool isPrime(int n) { if (n &lt;= 1) return false; for (int i = 2; i &lt;= n / i; i++) if (n % i == 0) return false; return true; } 线性筛法 int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 // 线性筛的原理是基于埃式筛，避免重复筛的情况，定义一个合数一定是被其最小质因子筛去的 void getPrimes(int n) { for (int i = 2; i &lt;= n; i++) { if (!st[i]) primes[cnt++] = i; // （1）. 如果 i % primes[j] == 0， 那么 primes[j] 一定是 i 最小质因子 // （2）. 在 （1） 没有发生的时候，primes[j] * i 的最小质因子一定是 primes[j]，此时 i 还没找到自己的最小质因子 // （3）所有合数都有自己的最小质因子，所以一定会被筛 for (int j = 0; primes[j] &lt;= n / i; j++) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 分解质因数 分解质因数 void divide(int n) { for (int i = 2; i &lt;= n / i; i++) { if (n % i == 0) { // 此时 i 一定是质数 int cnt = 0; while (n % i == 0) { cnt++; n /= i; } // 有 cnt 个 i printf(&quot;%d %d\\n&quot;, i, cnt); } } // 大于 sqrt(n) 的数 if (n &gt; 1) printf(&quot;%d 1\\n&quot;, n); puts(&quot;&quot;); } 约数 基本定理：任何一个大于 11 的自然数 NN ，如果 N 不为质数，那么 N 可以唯一分解成有限个质数的乘积 N=P1a1P2a2P3a3......PnanN=P^{a_1}_1P^{a_2}_2P^{a_3}_3......P^{a_n}_nN=P1a1​​P2a2​​P3a3​​......Pnan​​，这里 P1&lt;P2&lt;P3......&lt;PnP_1&lt;P_2&lt;P_3......&lt;P_nP1​&lt;P2​&lt;P3​......&lt;Pn​ 均为质数，其中指数 aiaiai 是正整数。 约数个数：(a1+1)∗(a2+1)∗...∗(an+1)(a_1 + 1) * (a_2 + 1)* ... * (a_n + 1)(a1​+1)∗(a2​+1)∗...∗(an​+1) 约数之和：(P10+P12+…+P1a1)∗…∗(Pn0+Pn2+…+Pna1)(P_{1}^{0}+P_{1}^{2}+…+P_{1}^{a1})∗…∗(P_{n}^{0}+P_{n}^{2}+…+P_{n}^{a1})(P10​+P12​+…+P1a1​)∗…∗(Pn0​+Pn2​+…+Pna1​) // n 个正整数 ai, 请你输出这些数的乘积的约数个数 #include &lt;iostream&gt; #include &lt;unordered_map&gt; using namespace std; const int m = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n--) { int k; cin &gt;&gt; k; for (int i = 2; i &lt;= k / i; i++) { while (k % i == 0) { primes[i]++; k /= i; } } if (k &gt; 1) primes[k]++; } long long ans = 1; for (auto[k, v] : primes) ans = ans * (v + 1) % m; cout &lt;&lt; ans &lt;&lt; endl; return 0; } // n 个正整数 ai，请你输出这些数的乘积的约数之和， #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n--) { int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i++) while (x % i == 0) { x /= i; primes[i]++; } if (x &gt; 1) primes[x]++; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b--) t = (t * a + 1) % mod; res = res * t % mod; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 最大公约数 ** 欧几里得算法** 又称辗转相除法，是指用于计算两个非负整数非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式 gcd(a,b)=gcd(b,aMODb)gcd(a,b) = gcd(b,a MOD b)gcd(a,b)=gcd(b,aMODb)。 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 扩展欧几里得算法：用来求 a∗x+b∗y=(a,b)a*x + b * y = (a, b)a∗x+b∗y=(a,b) 的 x、y 的解，其中 (a,b)(a,b)(a,b) 是 gcd(a,b)gcd(a, b)gcd(a,b), 为了表示简单，记为 ddd 通解为 ： $ x = x_0 + k * (b / d)$ 、$y =y_0 + k * (a/d) $ 代码实现 LL exgcd(LL a, LL b, LL&amp; x, LL&amp; y) { if(b == 0) { y = 0, x = 1; return a; } LL d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } 证明如下图： ","link":"https://tofindmore.github.io/post/shu-xue-zhi-shi-1-zhi-shu-yu-yue-shu/"},{"title":"【数据结构】线段树","content":"1.线段树基本介绍与实现 树状数组是一种基于分治思想的二叉树结构，用于在区间上进行信息统计，与按照二进制位进行区间划分的树状数组相比，线段树更加通用： 线段树每个节点都代表一个区间 线段树具有唯一的根节点，代表的区间是整个统计范围，如 [1,N][1, N][1,N] 线段树的每个叶子节点都代表一个长度为1的元区间 [x,x][x, x][x,x] 对于每个内部节点 [l,r][l, r][l,r]，他的左子节点是 [mid+1,r][mid+1, r][mid+1,r], 其中 mid = (l+r) &gt;&gt; 1 如下图所示，是一颗二叉树视角的线段树，我们要做的就是做好每个节点的统计信息。 线段树查询、更新的时间复杂度是O(logN)，空间复杂度是O(4N)（至于为什么，可以参照上图证明下就可以了），支持区间操作的（区间操作的时候要做懒标记，即 pushdown 操作）。 下面是实现方式 struct Node { int l, r; // TODO: 需要维护的信息和懒标记 }tr[N * 4]; void pushup(int u) { // TODO: 利用左右儿子信息维护当前节点的信息 } void pushdown(int u) { // TODO: 将懒标记下传 } void build(int u, int l, int r) { if (l == r) tr[u] = {l, r}; else { tr[u] = {l, r}; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void update(int u, int l, int r, int d) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) { // TODO: 修改区间 } else { pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) update(u &lt;&lt; 1, l, r, d); if (r &gt; mid) update(u &lt;&lt; 1 | 1, l, r, d); pushup(u); } } int query(int u, int l, int r) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) { return ; // TODO 需要补充返回值 } else { pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; int res = 0; if (l &lt;= mid ) res = query(u &lt;&lt; 1, l, r); if (r &gt; mid) res += query(u &lt;&lt; 1 | 1, l, r); return res; } } 2. 一些基本使用 【例题1】最大数 给定一个正整数数列 a1,a2,…,ana_1,a_2,…,a_na1​,a2​,…,an​ 每一个数都在 0∼p−1 之间。 可以对这列数进行两种操作： 添加操作：向序列后添加一个数，序列长度变成 n+1； 询问操作：询问这个序列中最后 L 个数中最大的数是多少。 程序运行的最开始，整数序列为空。 一共要对整数序列进行 m 次操作。 写一个程序，读入操作的序列，并输出询问操作的答案。 输入格式 第一行有两个正整数 m,p，意义如题目描述； 接下来 m 行，每一行表示一个操作。 如果该行的内容是 Q L，则表示这个操作是询问序列中最后 LL 个数的最大数是多少； 如果是 A t，则表示向序列后面加一个数，加入的数是 (t+a) mod p。其中，t 是输入的参数，a 是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 a=0）。 第一个操作一定是添加操作。对于询问操作，L&gt;0 且不超过当前序列的长度。 输出格式 对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 LL 个数的最大数。 数据范围 1≤m≤2×1051≤m≤2×10^51≤m≤2×105 1≤p≤2×1091≤p≤2×10^91≤p≤2×109 0≤t&lt;p0≤t&lt;p0≤t&lt;p 输入样例： 10 100 A 97 Q 1 Q 1 A 17 Q 2 A 63 Q 1 Q 1 Q 3 A 99 输出样例： 97 97 97 60 60 97 样例解释 最后的序列是 97,14,60,96 实现代码如下 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 2e5 + 10; struct Node { int l, r; int val; } tr[N &lt;&lt; 2]; void pushUp(int u) { tr[u].val = max(tr[u &lt;&lt; 1].val, tr[u &lt;&lt; 1 | 1].val); } void build(int l, int r, int u) { tr[u].l = l, tr[u].r = r; if (l == r) return; int mid = l + r &gt;&gt; 1; build(l, mid, u &lt;&lt; 1); build(mid + 1, r, u &lt;&lt; 1 | 1); } void modify(int u, int i, int v) { int l = tr[u].l, r = tr[u].r; if (l == r) { tr[u].val = v; return; } int mid = l + r &gt;&gt; 1; if (i &lt;= mid) modify(u &lt;&lt; 1, i, v); else modify(u &lt;&lt; 1 | 1, i, v); pushUp(u); } int query(int l, int r, int u) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].val; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (r &lt;= mid) return query(l, r, u &lt;&lt; 1); else if (l &gt; mid) return query(l, r, u &lt;&lt; 1 | 1); else return max(query(l, mid, u &lt;&lt; 1), query(mid + 1, r, u &lt;&lt; 1 | 1)); } int main() { int m, p, k, n = 0; int last = 0; build(1, N, 1); cin &gt;&gt; m &gt;&gt; p; while (m--) { char op[2]; scanf(&quot;%s%d&quot;, op, &amp;k); if (op[0] == 'Q') { last = query(n - k + 1, n, 1); cout &lt;&lt; last &lt;&lt; endl; } else { modify(1, ++n, (k + last) % p); } } return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-xian-duan-shu/"},{"title":"【数据结构】树状数组","content":"1. 树状数组基本介绍与实现 树状数组是一个动态维护前缀和的数据结构，其利用的是二进制位转化的关系，保证查询和插入的时间复杂度都是O (logN)， 空间复杂度为 O(N)。如下图所示，粉色代表开辟出的空间数组，代表指向的所有块的和。 如果要算出前7（111B）的和，如图可知，只需算出 4(100B)、6(110B)、7(111B) 3处的和即可，根据 7（111B）， 删去其2进制的末尾1即得到 6（110B）, 根据 6（110B）， 删去其2进制的末尾1即得到 4（100B）,使得其具有天然的关系性。（111 -&gt; 110 -&gt; 100） lowbit数组：对于数 x ， 可得到其末尾 1 的值 int lowbit(int x) { return x &amp; (-x); } 证明如下图 下面是实现方式（往往与离散化一起使用） int bit[N]; int lowbit(int x) { return x &amp; (-x); } int query(int x) { int ans = 0; while (x &gt; 0) { ans += bit[x]; x -= lowbit(x); } return ans; } void add(int x, int val) { while (x &lt; N) { bit[x] += val; x += lowbit(x); } } 2. 一些基本使用 【例题】逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 输入: [7,5,6,4] 输出: 5 实现代码如下 #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; const int SIZE = 5e5 + 10; class Solution { int bit[SIZE]; int lowbit(int x) { return x &amp; (-x); } int query(int x) { int ans = 0; while (x &gt; 0) { ans += bit[x]; x -= lowbit(x); } return ans; } void add(int x, int val) { while (x &lt; SIZE) { bit[x] += val; x += lowbit(x); } } unordered_map&lt;int, int&gt; real2idx; public: int reversePairs(vector&lt;int&gt; &amp;nums) { vector&lt;int&gt; copyNum(nums); // 离散化 sort(copyNum.begin(), copyNum.end()); int cnt = 1; for (int num : copyNum) { if (real2idx.count(num)) continue; real2idx[num] = cnt++; } int ans = 0; for (int num : nums) { ans += query(SIZE - 1) - query(real2idx[num]); add(real2idx[num], 1); } return ans; } }; ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-shu-zhuang-shu-zu/"},{"title":"【ZooKeeper】 （一）了解ZooKeeper ","content":" ZooKeeper 是一个分布式协调服务的开源框架。主要用来解决分布式集群中应用系统的一致性的问题。其本质上是一个分布式的小文件存储系统。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中 的节点进行有效管理。从而来维护和监控你存储的数据的状态变化。将通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。 Paxos算法： 虚拟同步技术(virtual synchrony)： 1.1 Zookeeper 基础 znode : 类似于文件系统的层级树状结构 ​ 在这个文件系统里面，是一个主-从结构的示例 ZooKeeper API暴露的方法： create/path data : 创建一个名为 /path 的 znode 节点，并包含数据 data delete/path : 删除 /path 的 znode exist/path : 检查是否存在名为 /path 的节点 setData/path data : 设置名为 /path 的 znode 的数据为 data getData/path : 返回名为 /path 节点的数据信息 getChildren/path : 返回所有 /path 节点的所有子节点列表 ZooKeeper 不允许局部写入或读取znode节点的数据 znode 的不同类型 当新建znode时，还需要指定该节点的类型(mode)，不同的类型 决定了znode节点的行为方式。 持久节点和临时节点 ： 持久的znode，如/path，只能通过调用delete来进行 删除。临时的znode与之相反，当创建该节点的客户端崩溃或关闭了与 ZooKeeper的连接时，这个节点就会被删除。 一个临时znode，在以下两种情况下将会被删除: 1.当创建该znode的客户端的会话因超时或主动关闭而中止时。 2.当某个客户端(不一定是创建者)主动删除该节点时。 有序节点 ： 一个有序znode节 点被分配唯一个单调递增的整数。当创建有序节点时，一个序号会被追加到路径之后。有序znode通过 提供了创建具有唯一名称的znode的简单方式。同时也通过这种方式可以直观地查看znode的创建顺序。 综上，znode一共有4种类型:持久的(persistent)、临时的 (ephemeral)、持久有序的(persistent_sequential)和临时有序的 (ephemeral_sequential)。 监视与通知 ZooKeeper通常以远程服务的方式被访问，如果每次访问znode时， 客户端都需要获得节点中的内容，这样的代价就非常大。因为这样会导致更高的延迟，而且ZooKeeper需要做更多的操作。 为此，基于通知的机制 ： 客户端向ZooKeeper注册需要接收通知的 znode，通过对znode设置监视点(watch)来接收通知。 版本 每一个znode都有一个版本号，它随着每次数据变化而自增。使用版本来阻止并行操作的不一致性。 1.2 Zookeeper 架构 ZooKeeper服务器端运行于两种模式下:独立模式(standalone)和 仲裁模式(quorum)。独立模式几乎与其术语所描述的一样:有一个单独的服务器，ZooKeeper状态无法复制。在仲裁模式下，具有一组 ZooKeeper服务器，我们称为ZooKeeper集合(ZooKeeper ensemble)，它们之前可以进行状态的复制，并同时为服务于客户端的请求。 这里重点介绍下 仲裁模式 ： 在仲裁模式下，ZooKeeper复制集群中的所有服务器的数据树。但如果让一个客户端等待每个服务器完成数据保存后再继续，延迟问题将无法接受。例如有5台机器，必须有3台进行操作确认；4台机器，必须有3台进行操作确认；可以看出，奇数台的性价比高些。 会话 在对ZooKeeper集合执行任何请求前，一个客户端必须先与服务建立会话。会话的概念非常重要，对ZooKeeper的运行也非常关键。客户端提交给ZooKeeper的所有操作均关联在一个会话上。当一个会话因某种原因而中止时，在这个会话期间创建的临时节点将会消失。 客户端通过TCP协议与服务器进行连接并通信， 但当会话无法与当前连接的服务器继续通信时，会话就可能转移到另一个服务器上。会话提供了顺序保障，这就意味着同一个会话中的请求会以FIFO(先进先出)顺序执行 2.3 开始使用ZooKeeper（MAC OS） 首先从官网下载zookeeper压缩包 https://zookeeper.apache.org/releases.html 找到需要下载的包 Apache ZooKeeper 3.7.0 Source Release(asc, sha512) 得到压缩包 apache-zookeeper-3.7.0-bin.tar.gz 进入相应文件夹，解压压缩包 tar -zxvf ./apache-zookeeper-3.7.0-bin.tar.gz 进入解压后的文件目录，修改配置文件，位于conf文件夹下, 重命名为 zoo.cfg 修改 zoo.cfg, 可以修改 DataDir 文件夹位置，用来zookeeper建目录用的 启动 ./bin/zkServer.sh start 上面这个命令是后台运行 如果想在前台运行并输出命令，可以用 ./bin/zkServer.sh start-foreground 暂停 ./bin/zkServer.sh stop 会话建立 ./bin/zkCli.sh 建立节点，删除并退出会话 ","link":"https://tofindmore.github.io/post/zookeeper-zhi-liao-jie-zookeeper/"},{"title":"【数据结构】单调栈 ","content":" 1. 何谓单调栈 单调栈即满足单调性的栈结构。在遇到实际情况时，需要将不需要维护的数据从栈顶弹出，维护队列单调性。 一般的处理代码如下 // 单调递增栈，插入 t while(!stk.empty() &amp;&amp; stk.top() &gt;= t) stk.pop(); stk.push(t); 2. 实际中的问题 P1 单调栈 给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。 // 根据题意，对于某个待插入的数 t 来说，之前所有比 t 大的数， 对于 t 及以后的数来说都是无用的 // 1. Why 对 t 无用? 答： t 要找比 t 小的 // 2. Why 对 t 以后的数？答：如果往前找，找t就好了，比 t 前面且比 t 大的数不需要再比较了 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { int n, t; cin &gt;&gt; n; stack&lt;int&gt; stk; for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;t); while (!stk.empty() &amp;&amp; stk.top() &gt;= t) stk.pop(); if (stk.empty()) cout &lt;&lt; &quot;-1 &quot;; else cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;; stk.push(t); } return 0; } P2 直方图中最大的矩形 如下图所示，直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为 2,1,4,5,1,3,32,1,4,5,1,3,3 的矩形组成的直方图，矩形的宽度都为 11： 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; using namespace std; typedef long long LL; const int N = 1e5 + 10; int l[N], r[N], g[N], n; int main() { while (scanf(&quot;%d&quot;, &amp;n), n) { for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, g + i); g[0] = -1, g[n + 1] = -1; // 初始化数组 l[i], 表示所有下标 i 左边第一个比他小的下标 stack&lt;int&gt; stk; stk.push(0); for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); l[i] = stk.top(); stk.push(i); } while (!stk.empty()) stk.pop(); stk.push(n + 1); // 初始化数组 r[i], 表示所有下标 i 右边第一个比他小的下标 for (int i = n; i &gt;= 1; i--) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); r[i] = stk.top(); stk.push(i); } // 枚举所有以 i 为顶边的情况 LL ans = 0; for (int i = 1; i &lt;= n; i++) { ans = max(ans, (LL) g[i] * (r[i] - l[i] - 1)); } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } P3 城市游戏 求被 F 覆盖的最大矩形面积， 本题就是上一题直接的变形，枚举每一行，就可以看做是一个直方图 R F F F F F F F F F F F R R R F F F F F F F F F F F F F F F #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; using namespace std; typedef long long LL; const int N = 1010; // mp[i][j] 表示第i行第j列方格上方包括自己有多少个F, 相当于上题中的矩形高度！！！ int l[N], r[N], mp[N][N]; int n, m; int solve(int g[]) { g[0] = -1, g[n + 1] = -1; // 初始化数组 l[i], 表示所有下标 i 左边第一个比他小的下标 stack&lt;int&gt; stk; stk.push(0); for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); l[i] = stk.top(); stk.push(i); } while (!stk.empty()) stk.pop(); stk.push(n + 1); // 初始化数组 r[i], 表示所有下标 i 右边第一个比他小的下标 for (int i = n; i &gt;= 1; i--) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); r[i] = stk.top(); stk.push(i); } // 枚举所有以 i 为顶边的情况 LL ans = 0; for (int i = 1; i &lt;= n; i++) { ans = max(ans, (LL) g[i] * (r[i] - l[i] - 1)); } return ans; } int main() { cin &gt;&gt; m &gt;&gt; n; char c[3]; int ans = 0; for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { scanf(&quot;%s&quot;, &amp;c); if(c[0] == 'F') mp[i][j] = mp[i-1][j] + 1; } ans = max(ans, solve(mp[i])); } cout &lt;&lt; ans * 3 &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-dan-diao-zhan/"},{"title":"【数据结构】Trie树","content":"1. Trie 树基本介绍与实现 Trie(字典树)是一种用于实现字符串（不一定是字符串，如一个整数的二进制串等）快速检索的多叉树结构。如下图所示，是字符串 &quot;cab&quot;、&quot;cos&quot;、&quot;car&quot;、&quot;cat&quot;、&quot;cate&quot;、&quot;rain&quot; 插入操作。 下面是建树、查找的代码实现 // tr[i][j] 表示下标 i 节点下 j 号子节点的下标， 此处26是仅有小写字母的合集 // idx 是自增的下标 int tr[M][26], idx; // 插入某个字符串 void insert(char *str) { // 初始化为根节点，表示当前节点 int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // 如果子节点不存在，创建一个新节点 if (!tr[p][u]) tr[p][u] = ++idx; // 更新往下迭代 p = tr[p][u]; } } // 查询某个字符串的信息，这里可以统计单词个数、前缀个数等 int query(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // ... p = tr[p][u]; } // 根据题目返回一些信息 return sth; } 2. Trie 的一些基本使用 2.1 【例题】字符串统计 维护一个字符串集合，支持两种操作： I x 向集合中插入一个字符串 x； Q x 询问一个字符串在集合中出现了多少次。 共有 N 个操作，输入的字符串总长度不超过 10510^5105，字符串仅包含小写英文字母。 输入格式 第一行包含整数 N，表示操作数。 接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。 输出格式 对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x 在集合中出现的次数。 每个结果占一行。 数据范围 1≤N≤2∗1041≤N≤2∗10^41≤N≤2∗104 输入样例： 5 I abc Q abc Q ab I ab Q ab 输出样例： 1 0 1 实现代码如下 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int tr[N][26], idx, cnt[N]; char op[2], str[N]; void insert(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!tr[p][u]) tr[p][u] = ++idx; p = tr[p][u]; } cnt[p]++; } int query(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!tr[p][u]) return 0; p = tr[p][u]; } return cnt[p]; } int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { scanf(&quot;%s%s&quot;, op, str); if (op[0] == 'I') insert(str); else cout &lt;&lt; query(str) &lt;&lt; endl; } return 0; } 2.2 【例题】最大异或对 在给定的 N 个整数 $A_1，A_2……A_N $中选出两个进行 xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数 N。 第二行输入 N 个整数 A1～ANA_1～A_NA1​～AN​。 输出格式 输出一个整数表示答案。 数据范围 1≤N≤1051≤N≤10^51≤N≤105 0≤Ai&lt;2310≤A_i&lt;2^{31}0≤Ai​&lt;231 输入样例： 3 1 2 3 输出样例： 3 实现代码如下 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10, M = 31 * N; int tr[M][2], idx, nums[N]; void insert(int x) { int p = 0; for (int i = 30; i &gt;= 0; i--) { int u = x &gt;&gt; i &amp; 1; if (!tr[p][u]) tr[p][u] = ++idx; p = tr[p][u]; } } int query(int x) { int p = 0, ret = 0; for (int i = 30; i &gt;= 0; i--) { int u = x &gt;&gt; i &amp; 1; if (tr[p][u ^ 1]) p = tr[p][u ^ 1], ret += (1 &lt;&lt; i); else p = tr[p][u]; } return ret; } int main() { int n, x; cin &gt;&gt; n; int tot = -1; while (n--) { cin &gt;&gt; x; insert(x); nums[++tot] = x; } int ans = 0; for (int i = 0; i &lt;= tot; i++) { ans = max(ans, query(nums[i])); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } 3. https://leetcode-cn.com/problems/maximum-genetic-difference-query/ 离线dfs + trie const int N = 1e5 + 100; const int B = 18; typedef pair&lt;int, int&gt; PII; class Solution { int idx = 1; int node[N*B][2]; int cnt[N*B]; unordered_map&lt;int, vector&lt;PII&gt;&gt; qm; unordered_map&lt;int, vector&lt;int&gt;&gt; sm; int head; void insert(int v) { int cur = head; cnt[cur]++; for(int i=B-1;i&gt;=0;i--) { int t = v &gt;&gt; i &amp; 1; if(node[cur][t] == 0) { node[cur][t] = idx++; } cur = node[cur][t]; cnt[cur]++; } } void erase(int v) { int cur = head; cnt[cur]--; for(int i=B-1;i&gt;=0;i--) { int t = v &gt;&gt; i &amp; 1; if(cnt[node[cur][t]] == 1) { node[cur][t] = 0; return; } cur = node[cur][t]; cnt[cur]--; } } int findMax(int v) { int ret = 0; int cur = head; for(int i=B-1;i&gt;=0;i--) { int t = v &gt;&gt; i &amp; 1; if(node[cur][t^1] &gt; 0) { cur = node[cur][t^1]; ret += 1 &lt;&lt; i; } else { cur = node[cur][t]; } } return ret; } vector&lt;int&gt; ans; void dfs(int u) { insert(u); vector&lt;PII&gt;&amp; p = qm[u]; for(int i=0;i&lt;p.size();i++) { PII&amp; t = p[i]; int tmp = findMax(t.first); ans[t.second] = findMax(t.first); } vector&lt;int&gt;&amp; son = sm[u]; for(int s : son) { dfs(s); } erase(u); } public: vector&lt;int&gt; maxGeneticDifference(vector&lt;int&gt;&amp; ps, vector&lt;vector&lt;int&gt;&gt;&amp; qs) { head = idx++; int qsize = qs.size(); for(int i=0;i&lt;qsize;i++) { auto&amp; q = qs[i]; qm[q[0]].push_back({q[1], i}); } for(int i=0;i&lt;ps.size();i++) { sm[ps[i]].push_back(i); } ans.resize(qs.size()); dfs(sm[-1][0]); return ans; } }; ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-trie-shu-ji-qi-chi-jiu-hua/"},{"title":"【数据结构】并查集","content":"1. 并查集基本介绍与实现 并查集（Disjoint-Set）是一种可以动态维护若干个不重合的集合，并支持合并和查询的数据结构。即有两种基本操作： Get ：查询一个元素属于哪一个集合 Merge ：把两个集合合并成一个大集合 为了防止插入退化，本博客使用的方法是：路径压缩（在find函数中利用传参赋值的方式） 下面是并查集的实现方式 int p[N]; void init() { for(int i=0;i&lt;N;i++) p[i] = i; } // 压缩后，时间复杂度可以认为是O(1) int find(int x) { // 此处进行了路径压缩 if (x != p[x]) p[x] = find(p[x]); return p[x]; } void merge(int x, int y) { int p1 = find(x); int p2 = find(y); // 如果两者不等， 说明不在同一个集合，将两者进行合并操作 if (p1 != p2) p[p1] = p2; } 2. 一些基本使用 【例题】程序自动分析 在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设 x1,x2,x3,…x1,x2,x3,…x1,x2,x3,…代表程序中出现的变量，给定 n 个形如 xi=xjxi=xj 或 xi≠xjx_i≠x_jxi​​=xj​ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。 例如，一个问题中的约束条件为：x1=x2，x2=x3，x3=x4，x1≠x4x1=x2，x2=x3，x3=x4，x1≠x4x1=x2，x2=x3，x3=x4，x1​=x4，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入格式 输入文件的第 1 行包含 1 个正整数 t，表示需要判定的问题个数，注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第 1 行包含 1 个正整数 n，表示该问题中需要被满足的约束条件个数。 接下来 n 行，每行包括 3 个整数 i,j,e，描述 1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 e=1e=1e=1，则该约束条件为 xi=xjx_i=x_jxi​=xj​；若 e=0e=0e=0，则该约束条件为 xi≠xjx_i≠x_jxi​​=xj​。 输出格式 输出文件包括 t 行。 输出文件的第 k 行输出一个字符串 YES 或者 NO，YES 表示输入中的第 kk 个问题判定为可以被满足，NO 表示不可被满足。 数据范围 $1≤n≤10^5 $ 1≤i,j≤1091≤i,j≤10^91≤i,j≤109 输入样例： 2 2 1 2 1 1 2 0 2 1 2 1 2 1 1 输出样例： NO YES 实现代码如下 // 本题要进行离散化处理，此处的离散方式是：排序 -&gt; 去重 -&gt; 二分查找 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int p[2 * N], nums[N * 2], op[N][3], len; int find(int x) { if (x != p[x]) p[x] = find(p[x]); return p[x]; } int getIdx(int x) { return lower_bound(nums, nums + len, x) - nums; } int main() { int T, n; cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; // 初始化操作 for (int i = 0; i &lt; 2 * N; i++) p[i] = i; int a, b, c; int cnt = -1; for (int i = 0; i &lt; n; i++) { scanf(&quot;%d%d%d&quot;, &amp;op[i][0], &amp;op[i][1], &amp;op[i][2]); nums[++cnt] = op[i][0], nums[++cnt] = op[i][1]; } // 离散化 sort(nums, nums + cnt + 1); len = unique(nums, nums + cnt + 1) - nums; // 对于相等的情况，先处理，进行合并 for (int i = 0; i &lt; n; i++) { if (op[i][2]) { int p1 = find(getIdx(op[i][0])); int p2 = find(getIdx(op[i][1])); if (p1 != p2) p[p1] = p2; } } // 对于不相等的情况，如果发现和之前矛盾吗，则输出NO bool flag = false; for (int i = 0; i &lt; n; i++) { if (!op[i][2]) { int p1 = find(getIdx(op[i][0])); int p2 = find(getIdx(op[i][1])); if (p1 == p2) { puts(&quot;NO&quot;), flag = true; break; } } } if (!flag) puts(&quot;YES&quot;); } return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-bing-cha-ji/"},{"title":"【图论】单源最短路","content":" 图的存储 对于有向图而言，有两种方式的图存储方式 邻接表 对于邻接表而言，推荐采用链式前向星数组的形式， 增加节点和便利节点的方式如下 // e[i] : 代表另外一个端点 // nxt[i] : 同一个链表下的下一个索引 // w[i] : 边长 // h[i] : 指向端点i的头节点 // idx : 下一条边的索引 int e[M], nxt[M], w[M], h[N], idx; // 一些初始化 void init() { // 刚开始所有的点都指向 -1 memset(h, -1, sizeof h); } // 添加a指向b且长度为c的有向边 void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } // 遍历 void demo { int cur = 1; for(int i=h[cur];i!=-1;i=nxt[i]) { // 另外一边 int k = e[i]; // .... } } 邻接矩阵 对于二维数组 g[i][j] 表示点 i 指向 j 存在 g[i][j] 长度的有向边 最短路算法 1. Dijkstra 这个算法采用了贪心策略，在每次可以遍历可以确定一个最优点 朴素的Dij 复杂度是 O(n2n^2n2)，n 是点数 朴素算法的瓶颈在于找出全局最小点，堆优化Dij采用最小堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;来对 dist[i] 维护，时间复杂度是 O(mlognmlognmlogn) ，其中m是边的个数 代码模板（朴素） const int N = 2021; int d[N][N], dist[N]; bool st[N]; // 使用的是邻接矩阵 void dijkstra() { dist[S] = 0; for (int i = 1; i &lt;= n; i++) { int cur = -1; // 找最小的那个（前提是这个边没有被找过） for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &gt; dist[j])) cur = j; st[cur] = true; // 更新最小点周围的边长 for (int j = 1; j &lt;= n; j++) if (dist[cur] + d[cur][j] &lt; dist[j]) dist[j] = dist[cur] + d[cur][j]; } } 代码模板（堆优化） typedef pair&lt;int, int&gt; PII; int dist[N], st[M]; // 使用的是邻接表 void dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 定义最小堆 priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; // 如果改节已被确定，则无需再进行相邻点更新 if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } 2. SPFA（Shortest Path Fast Algorithm） 这个算法是广搜的变形，很明显，当路径长度为1的时候，我们可以用BFS来算最短路。 这个算法在随机图上的时间复杂度是O(kmkmkm), k是一个很小的常数，对于特殊图，可能会达到O(mnmnmn) 的时间复杂度。 这个算法是可以处理负权边的 代码模板 // 起始点 S int dist[N], S; bool st[N]; // 使用的是邻接表 void spfa() { queue&lt;int&gt; que; que.push(S); dist[u] = 0, st[S] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; // 遍历所有相邻节点 for (int i = h[cur]; i != -1; i = ne[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; // 如果不在队列中，则加入队列 if (st[k] == 0) que.push(k); } } } } 3. Floyd（多源） 这个算法可以通过O(n3n^3n3)的时间复杂度算出任意两个点的最短路，是一种dp思路。 代码模板 int dist[N][N]; void floyd() { for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } 例题讲解 例题 做法描述 代码 AcWing 1129. 热浪 直接一遍spfa既可，也可以用dijkstra 🔗 AcWing 1128. 信使 数据量不大，可以直接一遍floyd，算出距离起点到各点之间的最短路长度的最大值 🔗 AcWing 1127. 香甜的黄油 对各节点进行一遍spfa，然后将各奶牛到该节点的最短路径相加取最小既可 🔗 AcWing 1126. 最小花费 乘法最大值（权值小于1），dijkstra修改为乘法的最短路，可以用log来证明其使用最短路 🔗 AcWing 920. 最优乘车 最小换乘，将单程链中每个节点的前驱都指向该节点，变成了最短路问题，答案就是最短路长度 - 1 🔗 AcWing 903. 昂贵的聘礼 建立一个虚拟节点， 注意所有交易链路的等级最小值和最大值不能超过M，用朴素dij暴力所有等级区间既可 🔗 AcWing 1135. 新年好 spfa会被卡，用堆优化的dij过的，主要就是求出1、a、b、c、d、e点各自的最短路，然后遍历路线即可 🔗 AcWing 1129. 热浪 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; const int N = 2510, M = 6210 &lt;&lt; 1; int start, en, n, m; int e[M], nxt[M], w[M], h[N], idx; int dist[N], st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } void spfa(int u) { queue&lt;int&gt; que; que.push(u); dist[u] = 0, st[u] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; for (int i = h[cur]; i != -1; i = nxt[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; if (st[k] == 0) que.push(k); } } } } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; en; memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= m; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c), add(b, a, c); } spfa(start); cout &lt;&lt; dist[en] &lt;&lt; endl; return 0; } AcWing 1128. 信使 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m; const int N = 110, INF = 0x3f3f3f3f; int dist[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= n; i++) dist[i][i] = 0; for (int i = 1; i &lt;= m; i++) { int p1, p2, dis; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis; dist[p1][p2] = dist[p2][p1] = min(dist[p1][p2], dis); } for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); int ans = -1; for (int i = 1; i &lt;= n; i++) { if (dist[1][i] == INF) { ans = -1; break; } ans = max(ans, dist[1][i]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1127. 香甜的黄油 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, p, c; const int N = 810, M = 510, T = 1510 * 2, INF = 0x3f3f3f3f; int r[N], dist[T]; bool st[T]; int ne[T], w[T], e[T], h[N], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void spfa(int S) { memset(st, 0, sizeof st); memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; que.push(S); dist[S] = 0; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (dist[u] + w[i] &lt; dist[j]) { dist[j] = dist[u] + w[i]; if (!st[j]) que.push(j), st[j] = true; } } } } int main() { cin &gt;&gt; n &gt;&gt; p &gt;&gt; c; memset(h, -1, sizeof h); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; r[i]; for (int i = 1; i &lt;= c; i++) { int a, b, wi; cin &gt;&gt; a &gt;&gt; b &gt;&gt; wi; add(a, b, wi), add(b, a, wi); } int ans = INF; for (int i = 1; i &lt;= p; i++) { spfa(i); int sum = 0, j = 1; for (; j &lt;= n; j++) { if (dist[r[j]] == INF) break; sum += dist[r[j]]; } if (j &lt;= n) continue; ans = min(ans, sum); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1126. 最小花费 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m, S, T; const int N = 2010, INF = 0x3f3f3f3f; double d[N][N], dist[N]; bool st[N]; double dijkstra() { dist[S] = 1.0; for (int i = 1; i &lt;= n; i++) { int cur = -1; for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &lt; dist[j])) cur = j; st[cur] = true; for (int j = 1; j &lt;= n; j++) if (dist[cur] * d[cur][j] &gt; dist[j]) dist[j] = dist[cur] * d[cur][j]; } return dist[T]; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; N; i++) d[i][i] = 1; for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); d[x][y] = d[y][x] = (100.0 - z * 1.0) / 100.0; } cin &gt;&gt; S &gt;&gt; T; printf(&quot;%.8lf\\n&quot;, 100.0 / dijkstra()); return 0; } AcWing 920. 最优乘车 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;sstream&gt; #include &lt;queue&gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int g[N][N], dist[N], stop[N]; bool st[N]; int n, m; void spfa() { memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; dist[1] = 0; que.push(1); st[1] = true; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = 1; i &lt;= n; i++) { if (g[u][i] + dist[u] &lt; dist[i]) { dist[i] = g[u][i] + dist[u]; if (!st[i]) que.push(i); } } } } int main() { memset(g, 0x3f, sizeof g); for (int i = 0; i &lt; N; i++) g[i][i] = 0; cin &gt;&gt; m &gt;&gt; n; string line; getline(cin, line); while (m--) { getline(cin, line); stringstream ssin(line); int cnt = 0, p; while (ssin &gt;&gt; p) stop[cnt++] = p; for (int i = 0; i &lt; cnt; i++) for (int j = i + 1; j &lt; cnt; j++) g[stop[i]][stop[j]] = 1; } spfa(); if (dist[n] == INF) puts(&quot;NO&quot;); else cout &lt;&lt; max(0, dist[n] - 1) &lt;&lt; endl; return 0; } AcWing 903. 昂贵的聘礼 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, m; int P, L, X; int T, V; const int N = 110, M = 110 * 110; struct Item { int id, p, l; }; unordered_map&lt;int, Item&gt; i2i; unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; mp; int ne[M], w[M], h[N], e[M], idx; int dist[N], st[M]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } typedef pair&lt;int, int&gt; PII; void dijkstra() // 求1号点到n号点的最短路距离 { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } void dijkstra(int l, int r) { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); dist[n + 1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, n + 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (i2i[j].l &lt; l || i2i[j].l &gt; r) continue; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;P, &amp;L, &amp;X); Item item = {i, P, L}; for (int j = 1; j &lt;= X; j++) { scanf(&quot;%d%d&quot;, &amp;T, &amp;V); mp[T][i] = V; } i2i[i] = item; } // 建边 for (auto[k, v] : mp) { for (auto[k1, v1] : v) { if (abs(i2i[k1].l - i2i[k].l) &lt;= m) { add(k, k1, v1); } } } // 虚拟节点 for (int i = 1; i &lt;= n; i++) add(n + 1, i, i2i[i].p); int ans = 0x3f3f3f3f; int le = i2i[1].l; for (int i = le - m; i &lt;= le; i++) { dijkstra(i, i + m); ans = min(ans, dist[1]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1135. 新年好 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;map&gt; using namespace std; const int N = 50010, M = 2e5 + 10, INF = 0x3f3f3f3f; int n, m, a, b, c, d, f; int ne[M], w[M], h[N], e[M], idx; int dist[6][N]; bool st[N]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } // void spfa(int distIdx, int S) { // auto &amp;dis = dist[distIdx]; // memset(st, 0, sizeof st); // memset(dis, 0x3f, sizeof dis); // queue&lt;int&gt; que; // que.push(S); // dis[S] = 0; // while(!que.empty()) { // int t = que.front(); // que.pop(); // st[t] = false; // for(int i=h[t];~i;i=ne[i]) { // int j = e[i]; // if(dis[t] + w[i] &lt; dis[j]) { // dis[j] = dis[t] + w[i]; // if(!st[j]) que.push(j), st[j] = true; // } // } // } // } typedef pair&lt;int, int&gt; PII; void dijkstra(int distIdx, int S) // 求1号点到n号点的最短路距离 { auto &amp;dis = dist[distIdx]; memset(dis, 0x3f, sizeof dis); memset(st, 0, sizeof st); dis[S] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, S}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dis[j] &gt; dis[ver] + w[i]) { dis[j] = dis[ver] + w[i]; heap.push({dis[j], j}); } } } } int main() { cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; f; memset(h, -1, sizeof h); for(int i=1;i&lt;=m;i++) { int a1, b1, c1; scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;b1, &amp;c1); add(a1, b1, c1), add(b1, a1, c1); } dijkstra(0, 1); dijkstra(1, a); dijkstra(2, b); dijkstra(3, c); dijkstra(4, d); dijkstra(5, f); vector&lt;int&gt; nums = {a, b, c, d, f}; sort(nums.begin(), nums.end()); unordered_map&lt;int, int&gt; mp; mp[a] = 1, mp[b] = 2, mp[c] = 3, mp[d] = 4, mp[f] = 5; int ans = INF; do { int t = dist[0][nums[0]]; for(int i=0;i&lt;4;i++) { t += dist[mp[nums[i]]][nums[i+1]]; } ans = min(ans, t); } while(next_permutation(nums.begin(), nums.end())); cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/tu-lun-dan-yuan-zui-duan-lu/"},{"title":"【DP】数位DP","content":" 算法介绍 这是一类形式比较固定的DP问题，往往是求在某个区间 [A, B] 中满足特定条件数的个数。做法基本上是下面的一套模板。 // 计算 0 - x 内有多少满足条件的数 int dp(int x) { // 0 特判 if(!x) return 0; // 记录数字x的各位上的数字 vector&lt;int&gt; nums; // B 为对应进制，通常是10进制下的问题 while(x) nums.push_back(x % B), x /= B; // 最终答案 int res = 0; // 上一位数的状态 int last = 0; for(int i=nums.size()-1;i&gt;=0;i--) { int t = nums[i]; // do sth. if(!i) { // do sth. } } return res; } 通常，对于 i 位上的数字 k , [0, k-1上的状态我们可以通过诸如区间DP方式求出来。 例题讲解 例题 做法描述 代码 AcWing 1081. 度的数量 直接看代码 🔗 AcWing 1082. 数字游戏 直接看代码 🔗 AcWing 1083. Windy数 直接看代码 🔗 AcWing 1084. 数字游戏 II 直接看代码 🔗 AcWing 1085. 不要62 直接看代码 🔗 AcWing 1081. 度的数量 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 32; LL f[N][N]; int X, Y, K, B; int dp(int x) { if (!x) return 0; vector&lt;int&gt; nums; while (x) nums.push_back(x % B), x /= B; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; if (t != 0) { if (t &gt; 1) { res += f[i + 1][K - last]; break; } else { res += f[i][K - last]; last++; if (last &gt; K) break; } } if (!i &amp;&amp; last == K) res++; } return res; } int main() { for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt;= i; j++) { if (j == 0) f[i][j] = 1; else f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; } } cin &gt;&gt; X &gt;&gt; Y &gt;&gt; K &gt;&gt; B; cout &lt;&lt; dp(Y) - dp(X - 1) &lt;&lt; endl; return 0; } ####AcWing 1082. 数字游戏 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1; else { for (int j = i; j &lt;= 9; j++) { f[i][len] += f[j][len - 1]; } } } } } int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if (last &gt; k) break; for (int j = last; j &lt; k; j++) { res += f[j][i + 1]; } last = k; if (!i) res++; } return res; } int main() { init(); // cout &lt;&lt; f[2][2] &lt;&lt; endl; while (cin &gt;&gt; a &gt;&gt; b) { cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } AcWing 1083. Windy数 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N], g[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1, g[i][len] = 1; else { for (int j = 0; j &lt;= 9; j++) { if (abs(j - i) &gt;= 2) { f[i][len] += f[j][len - 1]; } } if (i == 0) { for (int j = 0; j &lt;= 9; j++) { g[0][len] += g[j][len - 1]; } } else { g[i][len] = f[i][len]; } } } } } int dp(int x) { if (x &gt;= 0 &amp;&amp; x &lt;= 9) return x + 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = -2; bool flag = false; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if(k != 0) { if (!flag) { res += g[0][i + 1]; } else if (abs(last) &gt;= 2) { res += f[0][i + 1]; } for (int j = 1; j &lt; k; j++) { if (abs(last - j) &gt;= 2) { res += f[j][i + 1]; } } } if (abs(last - k) &lt;= 1) break; last = k; if (k != 0) flag = true; if (!i) res++; } return res; } int main() { init(); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; return 0; } ####AcWing 1084. 数字游戏 II #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N][105]; int mod; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) { f[i][len][i % mod] = 1; continue; } for (int j = 0; j &lt; mod; j++) { for (int k = 0; k &lt;= 9; k++) { f[i][len][j] += f[k][len - 1][((j - i) % mod + mod) % mod]; } } } } } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; for (int j = 0; j &lt; k; j++) { res += f[j][i + 1][((mod - last) % mod + mod) % mod]; } last = (last + k) % mod; if (!n &amp;&amp; last % mod == 0) res++; } return res; } int main() { while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod) { memset(f, 0, sizeof(f)); init(); cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } ####AcWing 1085. 不要62 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (i == 4) continue; if (len == 1) f[i][len] = 1; else { if (i == 6) for (int j = 0; j &lt;= 9; j++) { if (j == 2 || j== 4) continue; f[i][len] += f[j][len - 1]; } else { for (int j = 0; j &lt;= 9; j++) { if(j == 4) continue; f[i][len] += f[j][len - 1]; } } } } } } int n, m; int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int last = 0, res = 0; // res += f[0][nums.size()]; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; for (int j = 0; j &lt; t; j++) { // if(i == nums.size() - 1&amp;&amp; j == 0) continue; if(last == 6 &amp;&amp; j == 2) continue; if(j == 4) continue; res += f[j][i+1]; } if(t == 4) break; if(last == 6 &amp;&amp; t == 2) break; last = t; if(!i) res++; } return res; } int main() { init(); while (cin &gt;&gt; n &gt;&gt; m, !(n == 0 &amp;&amp; m == 0)) { cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; endl; } return 0; } ","link":"https://tofindmore.github.io/post/dp-shu-wei-dp/"},{"title":"【DP】状态压缩","content":" 算法介绍 这是一类把集合转化为整数记录在DP状态中的算法。假设 1 代表持有某种状态，那么对于十进制数 (11)D = (1011)B 来说可以表示为持有第 4 2 1 3种状态。 如下是 num 所持有的状态的所有子集（包含空集）。 int sub = num; do { // do sth sub = num &amp; (sub - 1); } while(sub != num) 通过子集预处理，可以减少枚举状态和一系列多余状态的判断 例题讲解 1. 棋盘类问题（基于连通性的DP） 棋盘类问题需要想清楚层与层之间的状态转移关系，通常是以 dp[i][s1] ～ dp[i-1][s2] 表示第 i 层状态 s1 是由 i-1 层状态转移而来，有时会牵扯到三层之间的关系，即 dp[i][s1] ～ dp[i-1][s2] and dp[i-2][s3] 本站相关例题讲解 例题 做法描述 代码 AcWing 1064. 小国王 dp[i][j][k]表示第i行状态为k且前i行共可以放j个国王 🔗 AcWing 327. 玉米田 dp[i][s] 表示第i层压缩状态位s的总种法 🔗 AcWing 292. 炮兵阵地 滚动数组 + dp[i][j][k]表示第i层状态j，i-1层状态为k 🔗 2. 集合类问题 // TODO AcWing 1064. 小国王 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; int n, m; vector&lt;int&gt; stateVec, head[2000]; LL dp[12][110][2000]; int cnt[2000]; bool check(int state) { for (int i = 0; i &lt; n; i++) { if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int count(int state) { int cnt = 0; for (int i = 0; i &lt; n; i++) if (state &gt;&gt; i &amp; 1) ++cnt; return cnt; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) if (check(i)) stateVec.push_back(i), cnt[i] = count(i); for (int i = 0; i &lt; stateVec.size(); i++) { for (int j = 0; j &lt; stateVec.size(); j++) { int a = stateVec[i], b = stateVec[j]; if (!(a &amp; b) &amp;&amp; check(a | b)) { head[a].push_back(b); } } } dp[0][0][0] = 1; for (int i = 1; i &lt;= n + 1; i++) { for (int j = 0; j &lt;= m; j++) { for (int k = 0; k &lt; stateVec.size(); k++) { int a = stateVec[k]; for (int t = 0; t &lt; head[a].size(); t++) { int c = cnt[a]; if (j &gt;= c) dp[i][j][a] += dp[i - 1][j - c][head[a][t]]; } } } } cout &lt;&lt; dp[n + 1][m][0] &lt;&lt; endl; return 0; } AcWing 327. 玉米田 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1 &lt;&lt; 13 + 10; const int M = 14, MOD = 1e8; int n, m, t; int id[M]; long long dp[M][N]; bool check(int s) { for (int i = 0; i &lt; m; i++) { if ((s &gt;&gt; i &amp; 1) &amp;&amp; (s &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; t; id[i] = (id[i] &lt;&lt; 1) + t; } } dp[0][0] = 1; long long ans = 0; for (int i = 1; i &lt;= n; i++) { int pre = id[i - 1], cur = id[i]; int s1 = cur; do { int s2 = pre; do { if (check(s1) &amp;&amp; check(s2) &amp;&amp; (s1 &amp; s2) == 0) { dp[i][s1] = (dp[i][s1] + dp[i - 1][s2]) % MOD; } s2 = (s2 - 1) &amp; pre; } while (s2 != pre); if (i == n) ans = (ans + dp[i][s1]) % MOD; s1 = (s1 - 1) &amp; cur; } while (s1 != cur); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 292. 炮兵阵地 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 110; const int M = 1 &lt;&lt; 10; int n, m; vector&lt;int&gt; id(N); int dp[2][M][M]; bool check(int s) { for (int i = 0; i &lt; m; i++) { int t = ((s &gt;&gt; i) &amp; 1) + ((s &gt;&gt; (i + 1)) &amp; 1) + ((s &gt;&gt; (i + 2)) &amp; 1); if (t &gt;= 2) return false; } return true; } int count(int s) { int ret = 0; for (int i = 0; i &lt;= m; i++) { if (s &gt;&gt; i &amp; 1) ret++; } return ret; } int main() { cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; head[N]; head[0].push_back(0); head[1].push_back(0); for (int i = 2; i &lt;= n + 1; i++) { for (int j = 0; j &lt; m; j++) { char c; cin &gt;&gt; c; id[i] = (id[i] &lt;&lt; 1) + (c == 'P'); } int s = id[i]; do { if (check(s)) head[i].push_back(s); s = (s - 1) &amp; id[i]; } while (s != id[i]); } int turn = 1; int ans = 0; for (int i = 2; i &lt;= n + 1; i++) { turn ^= 1; for (int j = 0; j &lt; head[i].size(); j++) { for (int k = 0; k &lt; head[i - 1].size(); k++) { for (int v = 0; v &lt; head[i - 2].size(); v++) { int c = head[i][j], p = head[i - 1][k], pp = head[i - 2][v]; if (((c &amp; p) == 0) &amp;&amp; ((pp &amp; p) == 0) &amp;&amp; ((pp &amp; c) == 0)) { dp[turn][c][p] = max(dp[turn ^ 1][p][pp] + count(c), dp[turn][c][p]); ans = max(ans, dp[turn][c][p]); } } } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/dp-zhuan-ti-zhuang-tai-ya-suo/"}]}