{"posts":[{"title":"ã€ZooKeeperã€‘ ï¼ˆä¸€ï¼‰äº†è§£ZooKeeper ","content":" ZooKeeper æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼åè°ƒæœåŠ¡çš„å¼€æºæ¡†æ¶ã€‚ä¸»è¦ç”¨æ¥è§£å†³åˆ†å¸ƒå¼é›†ç¾¤ä¸­åº”ç”¨ç³»ç»Ÿçš„ä¸€è‡´æ€§çš„é—®é¢˜ã€‚å…¶æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼çš„å°æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿã€‚æä¾›åŸºäºç±»ä¼¼äºæ–‡ä»¶ç³»ç»Ÿçš„ç›®å½•æ ‘æ–¹å¼çš„æ•°æ®å­˜å‚¨ï¼Œå¹¶ä¸”å¯ä»¥å¯¹æ ‘ç§ çš„èŠ‚ç‚¹è¿›è¡Œæœ‰æ•ˆç®¡ç†ã€‚ä»è€Œæ¥ç»´æŠ¤å’Œç›‘æ§ä½ å­˜å‚¨çš„æ•°æ®çš„çŠ¶æ€å˜åŒ–ã€‚å°†é€šè¿‡ç›‘æ§è¿™äº›æ•°æ®çŠ¶æ€çš„å˜åŒ–ï¼Œä»è€Œå¯ä»¥è¾¾åˆ°åŸºäºæ•°æ®çš„é›†ç¾¤ç®¡ç†ã€‚ Paxosç®—æ³•ï¼š è™šæ‹ŸåŒæ­¥æŠ€æœ¯(virtual synchrony)ï¼š 1.1 Zookeeper åŸºç¡€ znode : ç±»ä¼¼äºæ–‡ä»¶ç³»ç»Ÿçš„å±‚çº§æ ‘çŠ¶ç»“æ„ â€‹ åœ¨è¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿé‡Œé¢ï¼Œæ˜¯ä¸€ä¸ªä¸»-ä»ç»“æ„çš„ç¤ºä¾‹ ZooKeeper APIæš´éœ²çš„æ–¹æ³•ï¼š create/path data : åˆ›å»ºä¸€ä¸ªåä¸º /path çš„ znode èŠ‚ç‚¹ï¼Œå¹¶åŒ…å«æ•°æ® data delete/path : åˆ é™¤ /path çš„ znode exist/path : æ£€æŸ¥æ˜¯å¦å­˜åœ¨åä¸º /path çš„èŠ‚ç‚¹ setData/path data : è®¾ç½®åä¸º /path çš„ znode çš„æ•°æ®ä¸º data getData/path : è¿”å›åä¸º /path èŠ‚ç‚¹çš„æ•°æ®ä¿¡æ¯ **getChildren/path ** : è¿”å›æ‰€æœ‰ /path èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹åˆ—è¡¨ ZooKeeper ä¸å…è®¸å±€éƒ¨å†™å…¥æˆ–è¯»å–znodeèŠ‚ç‚¹çš„æ•°æ® znode çš„ä¸åŒç±»å‹ å½“æ–°å»ºznodeæ—¶ï¼Œè¿˜éœ€è¦æŒ‡å®šè¯¥èŠ‚ç‚¹çš„ç±»å‹(mode)ï¼Œä¸åŒçš„ç±»å‹ å†³å®šäº†znodeèŠ‚ç‚¹çš„è¡Œä¸ºæ–¹å¼ã€‚ æŒä¹…èŠ‚ç‚¹å’Œä¸´æ—¶èŠ‚ç‚¹ ï¼š æŒä¹…çš„znodeï¼Œå¦‚/pathï¼Œåªèƒ½é€šè¿‡è°ƒç”¨deleteæ¥è¿›è¡Œ åˆ é™¤ã€‚ä¸´æ—¶çš„znodeä¸ä¹‹ç›¸åï¼Œå½“åˆ›å»ºè¯¥èŠ‚ç‚¹çš„å®¢æˆ·ç«¯å´©æºƒæˆ–å…³é—­äº†ä¸ ZooKeeperçš„è¿æ¥æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹å°±ä¼šè¢«åˆ é™¤ã€‚ ä¸€ä¸ªä¸´æ—¶znodeï¼Œåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸‹å°†ä¼šè¢«åˆ é™¤: 1.å½“åˆ›å»ºè¯¥znodeçš„å®¢æˆ·ç«¯çš„ä¼šè¯å› è¶…æ—¶æˆ–ä¸»åŠ¨å…³é—­è€Œä¸­æ­¢æ—¶ã€‚ 2.å½“æŸä¸ªå®¢æˆ·ç«¯(ä¸ä¸€å®šæ˜¯åˆ›å»ºè€…)ä¸»åŠ¨åˆ é™¤è¯¥èŠ‚ç‚¹æ—¶ã€‚ æœ‰åºèŠ‚ç‚¹ ï¼š ä¸€ä¸ªæœ‰åºznodeèŠ‚ ç‚¹è¢«åˆ†é…å”¯ä¸€ä¸ªå•è°ƒé€’å¢çš„æ•´æ•°ã€‚å½“åˆ›å»ºæœ‰åºèŠ‚ç‚¹æ—¶ï¼Œä¸€ä¸ªåºå·ä¼šè¢«è¿½åŠ åˆ°è·¯å¾„ä¹‹åã€‚æœ‰åºznodeé€šè¿‡ æä¾›äº†åˆ›å»ºå…·æœ‰å”¯ä¸€åç§°çš„znodeçš„ç®€å•æ–¹å¼ã€‚åŒæ—¶ä¹Ÿé€šè¿‡è¿™ç§æ–¹å¼å¯ä»¥ç›´è§‚åœ°æŸ¥çœ‹znodeçš„åˆ›å»ºé¡ºåºã€‚ ç»¼ä¸Šï¼Œznodeä¸€å…±æœ‰4ç§ç±»å‹:æŒä¹…çš„(persistent)ã€ä¸´æ—¶çš„ (ephemeral)ã€æŒä¹…æœ‰åºçš„(persistent_sequential)å’Œä¸´æ—¶æœ‰åºçš„ (ephemeral_sequential)ã€‚ ç›‘è§†ä¸é€šçŸ¥ ZooKeeperé€šå¸¸ä»¥è¿œç¨‹æœåŠ¡çš„æ–¹å¼è¢«è®¿é—®ï¼Œå¦‚æœæ¯æ¬¡è®¿é—®znodeæ—¶ï¼Œ å®¢æˆ·ç«¯éƒ½éœ€è¦è·å¾—èŠ‚ç‚¹ä¸­çš„å†…å®¹ï¼Œè¿™æ ·çš„ä»£ä»·å°±éå¸¸å¤§ã€‚å› ä¸ºè¿™æ ·ä¼šå¯¼è‡´æ›´é«˜çš„å»¶è¿Ÿï¼Œè€Œä¸”ZooKeeperéœ€è¦åšæ›´å¤šçš„æ“ä½œã€‚ ä¸ºæ­¤ï¼ŒåŸºäºé€šçŸ¥çš„æœºåˆ¶ ï¼š å®¢æˆ·ç«¯å‘ZooKeeperæ³¨å†Œéœ€è¦æ¥æ”¶é€šçŸ¥çš„ znodeï¼Œé€šè¿‡å¯¹znodeè®¾ç½®ç›‘è§†ç‚¹(watch)æ¥æ¥æ”¶é€šçŸ¥ã€‚ ç‰ˆæœ¬ æ¯ä¸€ä¸ªznodeéƒ½æœ‰ä¸€ä¸ªç‰ˆæœ¬å·ï¼Œå®ƒéšç€æ¯æ¬¡æ•°æ®å˜åŒ–è€Œè‡ªå¢ã€‚ä½¿ç”¨ç‰ˆæœ¬æ¥é˜»æ­¢å¹¶è¡Œæ“ä½œçš„ä¸ä¸€è‡´æ€§ã€‚ 2.2 Zookeeper æ¶æ„ ZooKeeperæœåŠ¡å™¨ç«¯è¿è¡Œäºä¸¤ç§æ¨¡å¼ä¸‹:ç‹¬ç«‹æ¨¡å¼(standalone)å’Œ ä»²è£æ¨¡å¼(quorum)ã€‚ç‹¬ç«‹æ¨¡å¼å‡ ä¹ä¸å…¶æœ¯è¯­æ‰€æè¿°çš„ä¸€æ ·:æœ‰ä¸€ä¸ªå•ç‹¬çš„æœåŠ¡å™¨ï¼ŒZooKeeperçŠ¶æ€æ— æ³•å¤åˆ¶ã€‚åœ¨ä»²è£æ¨¡å¼ä¸‹ï¼Œå…·æœ‰ä¸€ç»„ ZooKeeperæœåŠ¡å™¨ï¼Œæˆ‘ä»¬ç§°ä¸ºZooKeeperé›†åˆ(ZooKeeper ensemble)ï¼Œå®ƒä»¬ä¹‹å‰å¯ä»¥è¿›è¡ŒçŠ¶æ€çš„å¤åˆ¶ï¼Œå¹¶åŒæ—¶ä¸ºæœåŠ¡äºå®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚ è¿™é‡Œé‡ç‚¹ä»‹ç»ä¸‹ ä»²è£æ¨¡å¼ ï¼š åœ¨ä»²è£æ¨¡å¼ä¸‹ï¼ŒZooKeeperå¤åˆ¶é›†ç¾¤ä¸­çš„æ‰€æœ‰æœåŠ¡å™¨çš„æ•°æ®æ ‘ã€‚ä½†å¦‚æœè®©ä¸€ä¸ªå®¢æˆ·ç«¯ç­‰å¾…æ¯ä¸ªæœåŠ¡å™¨å®Œæˆæ•°æ®ä¿å­˜åå†ç»§ç»­ï¼Œå»¶è¿Ÿé—®é¢˜å°†æ— æ³•æ¥å—ã€‚ä¾‹å¦‚æœ‰5å°æœºå™¨ï¼Œå¿…é¡»æœ‰3å°è¿›è¡Œæ“ä½œç¡®è®¤ï¼›4å°æœºå™¨ï¼Œå¿…é¡»æœ‰3å°è¿›è¡Œæ“ä½œç¡®è®¤ï¼›å¯ä»¥çœ‹å‡ºï¼Œå¥‡æ•°å°çš„æ€§ä»·æ¯”é«˜äº›ã€‚ ä¼šè¯ åœ¨å¯¹ZooKeeperé›†åˆæ‰§è¡Œä»»ä½•è¯·æ±‚å‰ï¼Œä¸€ä¸ªå®¢æˆ·ç«¯å¿…é¡»å…ˆä¸æœåŠ¡å»ºç«‹ä¼šè¯ã€‚ä¼šè¯çš„æ¦‚å¿µéå¸¸é‡è¦ï¼Œå¯¹ZooKeeperçš„è¿è¡Œä¹Ÿéå¸¸å…³é”®ã€‚å®¢æˆ·ç«¯æäº¤ç»™ZooKeeperçš„æ‰€æœ‰æ“ä½œå‡å…³è”åœ¨ä¸€ä¸ªä¼šè¯ä¸Šã€‚å½“ä¸€ä¸ªä¼šè¯å› æŸç§åŸå› è€Œä¸­æ­¢æ—¶ï¼Œåœ¨è¿™ä¸ªä¼šè¯æœŸé—´åˆ›å»ºçš„ä¸´æ—¶èŠ‚ç‚¹å°†ä¼šæ¶ˆå¤±ã€‚ å®¢æˆ·ç«¯é€šè¿‡TCPåè®®ä¸æœåŠ¡å™¨è¿›è¡Œè¿æ¥å¹¶é€šä¿¡ï¼Œ ä½†å½“ä¼šè¯æ— æ³•ä¸å½“å‰è¿æ¥çš„æœåŠ¡å™¨ç»§ç»­é€šä¿¡æ—¶ï¼Œä¼šè¯å°±å¯èƒ½è½¬ç§»åˆ°å¦ä¸€ä¸ªæœåŠ¡å™¨ä¸Šã€‚ä¼šè¯æä¾›äº†é¡ºåºä¿éšœï¼Œè¿™å°±æ„å‘³ç€åŒä¸€ä¸ªä¼šè¯ä¸­çš„è¯·æ±‚ä¼šä»¥FIFO(å…ˆè¿›å…ˆå‡º)é¡ºåºæ‰§è¡Œ 2.3 å¼€å§‹ä½¿ç”¨ZooKeeper // TODO ","link":"https://tofindmore.github.io/post/zookeeper-zhi-liao-jie-zookeeper/"},{"title":"ã€æ•°æ®ç»“æ„ã€‘å•è°ƒæ ˆ ","content":" 1. ä½•è°“å•è°ƒæ ˆ å•è°ƒæ ˆå³æ»¡è¶³å•è°ƒæ€§çš„æ ˆç»“æ„ã€‚åœ¨é‡åˆ°å®é™…æƒ…å†µæ—¶ï¼Œéœ€è¦å°†ä¸éœ€è¦ç»´æŠ¤çš„æ•°æ®ä»æ ˆé¡¶å¼¹å‡ºï¼Œç»´æŠ¤é˜Ÿåˆ—å•è°ƒæ€§ã€‚ ä¸€èˆ¬çš„å¤„ç†ä»£ç å¦‚ä¸‹ // å•è°ƒé€’å¢æ ˆï¼Œæ’å…¥ t while(!stk.empty() &amp;&amp; stk.top() &gt;= t) stk.pop(); stk.push(t); 2. å®é™…ä¸­çš„é—®é¢˜ P1 å•è°ƒæ ˆ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º N çš„æ•´æ•°æ•°åˆ—ï¼Œè¾“å‡ºæ¯ä¸ªæ•°å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„æ•°ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¾“å‡º âˆ’1ã€‚ // æ ¹æ®é¢˜æ„ï¼Œå¯¹äºæŸä¸ªå¾…æ’å…¥çš„æ•° t æ¥è¯´ï¼Œä¹‹å‰æ‰€æœ‰æ¯” t å¤§çš„æ•°ï¼Œ å¯¹äº t åŠä»¥åçš„æ•°æ¥è¯´éƒ½æ˜¯æ— ç”¨çš„ // 1. Why å¯¹ t æ— ç”¨? ç­”ï¼š t è¦æ‰¾æ¯” t å°çš„ // 2. Why å¯¹ t ä»¥åçš„æ•°ï¼Ÿç­”ï¼šå¦‚æœå¾€å‰æ‰¾ï¼Œæ‰¾tå°±å¥½äº†ï¼Œæ¯” t å‰é¢ä¸”æ¯” t å¤§çš„æ•°ä¸éœ€è¦å†æ¯”è¾ƒäº† #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { int n, t; cin &gt;&gt; n; stack&lt;int&gt; stk; for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;t); while (!stk.empty() &amp;&amp; stk.top() &gt;= t) stk.pop(); if (stk.empty()) cout &lt;&lt; &quot;-1 &quot;; else cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;; stk.push(t); } return 0; } P2 ç›´æ–¹å›¾ä¸­æœ€å¤§çš„çŸ©å½¢ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œç›´æ–¹å›¾æ˜¯ç”±åœ¨å…¬å…±åŸºçº¿å¤„å¯¹é½çš„ä¸€ç³»åˆ—çŸ©å½¢ç»„æˆçš„å¤šè¾¹å½¢ã€‚ çŸ©å½¢å…·æœ‰ç›¸ç­‰çš„å®½åº¦ï¼Œä½†å¯ä»¥å…·æœ‰ä¸åŒçš„é«˜åº¦ã€‚ ä¾‹å¦‚ï¼Œå›¾ä¾‹å·¦ä¾§æ˜¾ç¤ºäº†ç”±é«˜åº¦ä¸º 2,1,4,5,1,3,32,1,4,5,1,3,3 çš„çŸ©å½¢ç»„æˆçš„ç›´æ–¹å›¾ï¼ŒçŸ©å½¢çš„å®½åº¦éƒ½ä¸º 11ï¼š ç°åœ¨ï¼Œè¯·ä½ è®¡ç®—åœ¨å…¬å…±åŸºçº¿å¤„å¯¹é½çš„ç›´æ–¹å›¾ä¸­æœ€å¤§çŸ©å½¢çš„é¢ç§¯ã€‚ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; using namespace std; typedef long long LL; const int N = 1e5 + 10; int l[N], r[N], g[N], n; int main() { while (scanf(&quot;%d&quot;, &amp;n), n) { for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, g + i); g[0] = -1, g[n + 1] = -1; // åˆå§‹åŒ–æ•°ç»„ l[i], è¡¨ç¤ºæ‰€æœ‰ä¸‹æ ‡ i å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„ä¸‹æ ‡ stack&lt;int&gt; stk; stk.push(0); for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); l[i] = stk.top(); stk.push(i); } while (!stk.empty()) stk.pop(); stk.push(n + 1); // åˆå§‹åŒ–æ•°ç»„ r[i], è¡¨ç¤ºæ‰€æœ‰ä¸‹æ ‡ i å³è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„ä¸‹æ ‡ for (int i = n; i &gt;= 1; i--) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); r[i] = stk.top(); stk.push(i); } // æšä¸¾æ‰€æœ‰ä»¥ i ä¸ºé¡¶è¾¹çš„æƒ…å†µ LL ans = 0; for (int i = 1; i &lt;= n; i++) { ans = max(ans, (LL) g[i] * (r[i] - l[i] - 1)); } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } P3 åŸå¸‚æ¸¸æˆ æ±‚è¢« F è¦†ç›–çš„æœ€å¤§çŸ©å½¢é¢ç§¯ï¼Œ æœ¬é¢˜å°±æ˜¯ä¸Šä¸€é¢˜ç›´æ¥çš„å˜å½¢ï¼Œæšä¸¾æ¯ä¸€è¡Œï¼Œå°±å¯ä»¥çœ‹åšæ˜¯ä¸€ä¸ªç›´æ–¹å›¾ R F F F F F F F F F F F R R R F F F F F F F F F F F F F F F #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; using namespace std; typedef long long LL; const int N = 1010; // mp[i][j] è¡¨ç¤ºç¬¬iè¡Œç¬¬jåˆ—æ–¹æ ¼ä¸Šæ–¹åŒ…æ‹¬è‡ªå·±æœ‰å¤šå°‘ä¸ªF, ç›¸å½“äºä¸Šé¢˜ä¸­çš„çŸ©å½¢é«˜åº¦ï¼ï¼ï¼ int l[N], r[N], mp[N][N]; int n, m; int solve(int g[]) { g[0] = -1, g[n + 1] = -1; // åˆå§‹åŒ–æ•°ç»„ l[i], è¡¨ç¤ºæ‰€æœ‰ä¸‹æ ‡ i å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„ä¸‹æ ‡ stack&lt;int&gt; stk; stk.push(0); for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); l[i] = stk.top(); stk.push(i); } while (!stk.empty()) stk.pop(); stk.push(n + 1); // åˆå§‹åŒ–æ•°ç»„ r[i], è¡¨ç¤ºæ‰€æœ‰ä¸‹æ ‡ i å³è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„ä¸‹æ ‡ for (int i = n; i &gt;= 1; i--) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); r[i] = stk.top(); stk.push(i); } // æšä¸¾æ‰€æœ‰ä»¥ i ä¸ºé¡¶è¾¹çš„æƒ…å†µ LL ans = 0; for (int i = 1; i &lt;= n; i++) { ans = max(ans, (LL) g[i] * (r[i] - l[i] - 1)); } return ans; } int main() { cin &gt;&gt; m &gt;&gt; n; char c[3]; int ans = 0; for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { scanf(&quot;%s&quot;, &amp;c); if(c[0] == 'F') mp[i][j] = mp[i-1][j] + 1; } ans = max(ans, solve(mp[i])); } cout &lt;&lt; ans * 3 &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-dan-diao-zhan/"},{"title":"ã€å›¾è®ºã€‘å•æºæœ€çŸ­è·¯","content":" å›¾çš„å­˜å‚¨ å¯¹äºæœ‰å‘å›¾è€Œè¨€ï¼Œæœ‰ä¸¤ç§æ–¹å¼çš„å›¾å­˜å‚¨æ–¹å¼ é‚»æ¥è¡¨ å¯¹äºé‚»æ¥è¡¨è€Œè¨€ï¼Œæ¨èé‡‡ç”¨é“¾å¼å‰å‘æ˜Ÿæ•°ç»„çš„å½¢å¼ï¼Œ å¢åŠ èŠ‚ç‚¹å’Œä¾¿åˆ©èŠ‚ç‚¹çš„æ–¹å¼å¦‚ä¸‹ // e[i] : ä»£è¡¨å¦å¤–ä¸€ä¸ªç«¯ç‚¹ // nxt[i] : åŒä¸€ä¸ªé“¾è¡¨ä¸‹çš„ä¸‹ä¸€ä¸ªç´¢å¼• // w[i] : è¾¹é•¿ // h[i] : æŒ‡å‘ç«¯ç‚¹içš„å¤´èŠ‚ç‚¹ // idx : ä¸‹ä¸€æ¡è¾¹çš„ç´¢å¼• int e[M], nxt[M], w[M], h[N], idx; // ä¸€äº›åˆå§‹åŒ– void init() { // åˆšå¼€å§‹æ‰€æœ‰çš„ç‚¹éƒ½æŒ‡å‘ -1 memset(h, -1, sizeof h); } // æ·»åŠ aæŒ‡å‘bä¸”é•¿åº¦ä¸ºcçš„æœ‰å‘è¾¹ void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } // éå† void demo { int cur = 1; for(int i=h[cur];i!=-1;i=nxt[i]) { // å¦å¤–ä¸€è¾¹ int k = e[i]; // .... } } é‚»æ¥çŸ©é˜µ å¯¹äºäºŒç»´æ•°ç»„ g[i][j] è¡¨ç¤ºç‚¹ i æŒ‡å‘ j å­˜åœ¨ g[i][j] é•¿åº¦çš„æœ‰å‘è¾¹ æœ€çŸ­è·¯ç®—æ³• 1. Dijkstra è¿™ä¸ªç®—æ³•é‡‡ç”¨äº†è´ªå¿ƒç­–ç•¥ï¼Œåœ¨æ¯æ¬¡å¯ä»¥éå†å¯ä»¥ç¡®å®šä¸€ä¸ªæœ€ä¼˜ç‚¹ æœ´ç´ çš„Dij å¤æ‚åº¦æ˜¯ O(n2n^2n2)ï¼Œn æ˜¯ç‚¹æ•° æœ´ç´ ç®—æ³•çš„ç“¶é¢ˆåœ¨äºæ‰¾å‡ºå…¨å±€æœ€å°ç‚¹ï¼Œå †ä¼˜åŒ–Dijé‡‡ç”¨æœ€å°å †priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;æ¥å¯¹ dist[i] ç»´æŠ¤ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(mlognmlognmlogn) ï¼Œå…¶ä¸­mæ˜¯è¾¹çš„ä¸ªæ•° ä»£ç æ¨¡æ¿ï¼ˆæœ´ç´ ï¼‰ const int N = 2021; int d[N][N], dist[N]; bool st[N]; // ä½¿ç”¨çš„æ˜¯é‚»æ¥çŸ©é˜µ void dijkstra() { dist[S] = 0; for (int i = 1; i &lt;= n; i++) { int cur = -1; // æ‰¾æœ€å°çš„é‚£ä¸ªï¼ˆå‰ææ˜¯è¿™ä¸ªè¾¹æ²¡æœ‰è¢«æ‰¾è¿‡ï¼‰ for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &gt; dist[j])) cur = j; st[cur] = true; // æ›´æ–°æœ€å°ç‚¹å‘¨å›´çš„è¾¹é•¿ for (int j = 1; j &lt;= n; j++) if (dist[cur] + d[cur][j] &lt; dist[j]) dist[j] = dist[cur] + d[cur][j]; } } ä»£ç æ¨¡æ¿ï¼ˆå †ä¼˜åŒ–ï¼‰ typedef pair&lt;int, int&gt; PII; int dist[N], st[M]; // ä½¿ç”¨çš„æ˜¯é‚»æ¥è¡¨ void dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // å®šä¹‰æœ€å°å † priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; // å¦‚æœæ”¹èŠ‚å·²è¢«ç¡®å®šï¼Œåˆ™æ— éœ€å†è¿›è¡Œç›¸é‚»ç‚¹æ›´æ–° if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } 2. SPFAï¼ˆShortest Path Fast Algorithmï¼‰ è¿™ä¸ªç®—æ³•æ˜¯å¹¿æœçš„å˜å½¢ï¼Œå¾ˆæ˜æ˜¾ï¼Œå½“è·¯å¾„é•¿åº¦ä¸º1çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨BFSæ¥ç®—æœ€çŸ­è·¯ã€‚ è¿™ä¸ªç®—æ³•åœ¨éšæœºå›¾ä¸Šçš„æ—¶é—´å¤æ‚åº¦æ˜¯O(kmkmkm), kæ˜¯ä¸€ä¸ªå¾ˆå°çš„å¸¸æ•°ï¼Œå¯¹äºç‰¹æ®Šå›¾ï¼Œå¯èƒ½ä¼šè¾¾åˆ°O(mnmnmn) çš„æ—¶é—´å¤æ‚åº¦ã€‚ è¿™ä¸ªç®—æ³•æ˜¯å¯ä»¥å¤„ç†è´Ÿæƒè¾¹çš„ ä»£ç æ¨¡æ¿ // èµ·å§‹ç‚¹ S int dist[N], S; bool st[N]; // ä½¿ç”¨çš„æ˜¯é‚»æ¥è¡¨ void spfa() { queue&lt;int&gt; que; que.push(S); dist[u] = 0, st[S] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; // éå†æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹ for (int i = h[cur]; i != -1; i = ne[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; // å¦‚æœä¸åœ¨é˜Ÿåˆ—ä¸­ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ— if (st[k] == 0) que.push(k); } } } } 3. Floydï¼ˆå¤šæºï¼‰ è¿™ä¸ªç®—æ³•å¯ä»¥é€šè¿‡O(n3n^3n3)çš„æ—¶é—´å¤æ‚åº¦ç®—å‡ºä»»æ„ä¸¤ä¸ªç‚¹çš„æœ€çŸ­è·¯ï¼Œæ˜¯ä¸€ç§dpæ€è·¯ã€‚ ä»£ç æ¨¡æ¿ int dist[N][N]; void floyd() { for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } ä¾‹é¢˜è®²è§£ ä¾‹é¢˜ åšæ³•æè¿° ä»£ç  AcWing 1129. çƒ­æµª ç›´æ¥ä¸€éspfaæ—¢å¯ï¼Œä¹Ÿå¯ä»¥ç”¨dijkstra ğŸ”— AcWing 1128. ä¿¡ä½¿ æ•°æ®é‡ä¸å¤§ï¼Œå¯ä»¥ç›´æ¥ä¸€éfloydï¼Œç®—å‡ºè·ç¦»èµ·ç‚¹åˆ°å„ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯é•¿åº¦çš„æœ€å¤§å€¼ ğŸ”— AcWing 1127. é¦™ç”œçš„é»„æ²¹ å¯¹å„èŠ‚ç‚¹è¿›è¡Œä¸€éspfaï¼Œç„¶åå°†å„å¥¶ç‰›åˆ°è¯¥èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ç›¸åŠ å–æœ€å°æ—¢å¯ ğŸ”— AcWing 1126. æœ€å°èŠ±è´¹ ä¹˜æ³•æœ€å¤§å€¼ï¼ˆæƒå€¼å°äº1ï¼‰ï¼Œdijkstraä¿®æ”¹ä¸ºä¹˜æ³•çš„æœ€çŸ­è·¯ï¼Œå¯ä»¥ç”¨logæ¥è¯æ˜å…¶ä½¿ç”¨æœ€çŸ­è·¯ ğŸ”— AcWing 920. æœ€ä¼˜ä¹˜è½¦ æœ€å°æ¢ä¹˜ï¼Œå°†å•ç¨‹é“¾ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å‰é©±éƒ½æŒ‡å‘è¯¥èŠ‚ç‚¹ï¼Œå˜æˆäº†æœ€çŸ­è·¯é—®é¢˜ï¼Œç­”æ¡ˆå°±æ˜¯æœ€çŸ­è·¯é•¿åº¦ - 1 ğŸ”— AcWing 903. æ˜‚è´µçš„è˜ç¤¼ å»ºç«‹ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼Œ æ³¨æ„æ‰€æœ‰äº¤æ˜“é“¾è·¯çš„ç­‰çº§æœ€å°å€¼å’Œæœ€å¤§å€¼ä¸èƒ½è¶…è¿‡Mï¼Œç”¨æœ´ç´ dijæš´åŠ›æ‰€æœ‰ç­‰çº§åŒºé—´æ—¢å¯ ğŸ”— AcWing 1135. æ–°å¹´å¥½ spfaä¼šè¢«å¡ï¼Œç”¨å †ä¼˜åŒ–çš„dijè¿‡çš„ï¼Œä¸»è¦å°±æ˜¯æ±‚å‡º1ã€aã€bã€cã€dã€eç‚¹å„è‡ªçš„æœ€çŸ­è·¯ï¼Œç„¶åéå†è·¯çº¿å³å¯ ğŸ”— AcWing 1129. çƒ­æµª #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; const int N = 2510, M = 6210 &lt;&lt; 1; int start, en, n, m; int e[M], nxt[M], w[M], h[N], idx; int dist[N], st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } void spfa(int u) { queue&lt;int&gt; que; que.push(u); dist[u] = 0, st[u] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; for (int i = h[cur]; i != -1; i = nxt[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; if (st[k] == 0) que.push(k); } } } } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; en; memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= m; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c), add(b, a, c); } spfa(start); cout &lt;&lt; dist[en] &lt;&lt; endl; return 0; } AcWing 1128. ä¿¡ä½¿ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m; const int N = 110, INF = 0x3f3f3f3f; int dist[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= n; i++) dist[i][i] = 0; for (int i = 1; i &lt;= m; i++) { int p1, p2, dis; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis; dist[p1][p2] = dist[p2][p1] = min(dist[p1][p2], dis); } for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); int ans = -1; for (int i = 1; i &lt;= n; i++) { if (dist[1][i] == INF) { ans = -1; break; } ans = max(ans, dist[1][i]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1127. é¦™ç”œçš„é»„æ²¹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, p, c; const int N = 810, M = 510, T = 1510 * 2, INF = 0x3f3f3f3f; int r[N], dist[T]; bool st[T]; int ne[T], w[T], e[T], h[N], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void spfa(int S) { memset(st, 0, sizeof st); memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; que.push(S); dist[S] = 0; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (dist[u] + w[i] &lt; dist[j]) { dist[j] = dist[u] + w[i]; if (!st[j]) que.push(j), st[j] = true; } } } } int main() { cin &gt;&gt; n &gt;&gt; p &gt;&gt; c; memset(h, -1, sizeof h); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; r[i]; for (int i = 1; i &lt;= c; i++) { int a, b, wi; cin &gt;&gt; a &gt;&gt; b &gt;&gt; wi; add(a, b, wi), add(b, a, wi); } int ans = INF; for (int i = 1; i &lt;= p; i++) { spfa(i); int sum = 0, j = 1; for (; j &lt;= n; j++) { if (dist[r[j]] == INF) break; sum += dist[r[j]]; } if (j &lt;= n) continue; ans = min(ans, sum); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1126. æœ€å°èŠ±è´¹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m, S, T; const int N = 2010, INF = 0x3f3f3f3f; double d[N][N], dist[N]; bool st[N]; double dijkstra() { dist[S] = 1.0; for (int i = 1; i &lt;= n; i++) { int cur = -1; for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &lt; dist[j])) cur = j; st[cur] = true; for (int j = 1; j &lt;= n; j++) if (dist[cur] * d[cur][j] &gt; dist[j]) dist[j] = dist[cur] * d[cur][j]; } return dist[T]; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; N; i++) d[i][i] = 1; for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); d[x][y] = d[y][x] = (100.0 - z * 1.0) / 100.0; } cin &gt;&gt; S &gt;&gt; T; printf(&quot;%.8lf\\n&quot;, 100.0 / dijkstra()); return 0; } AcWing 920. æœ€ä¼˜ä¹˜è½¦ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;sstream&gt; #include &lt;queue&gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int g[N][N], dist[N], stop[N]; bool st[N]; int n, m; void spfa() { memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; dist[1] = 0; que.push(1); st[1] = true; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = 1; i &lt;= n; i++) { if (g[u][i] + dist[u] &lt; dist[i]) { dist[i] = g[u][i] + dist[u]; if (!st[i]) que.push(i); } } } } int main() { memset(g, 0x3f, sizeof g); for (int i = 0; i &lt; N; i++) g[i][i] = 0; cin &gt;&gt; m &gt;&gt; n; string line; getline(cin, line); while (m--) { getline(cin, line); stringstream ssin(line); int cnt = 0, p; while (ssin &gt;&gt; p) stop[cnt++] = p; for (int i = 0; i &lt; cnt; i++) for (int j = i + 1; j &lt; cnt; j++) g[stop[i]][stop[j]] = 1; } spfa(); if (dist[n] == INF) puts(&quot;NO&quot;); else cout &lt;&lt; max(0, dist[n] - 1) &lt;&lt; endl; return 0; } AcWing 903. æ˜‚è´µçš„è˜ç¤¼ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, m; int P, L, X; int T, V; const int N = 110, M = 110 * 110; struct Item { int id, p, l; }; unordered_map&lt;int, Item&gt; i2i; unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; mp; int ne[M], w[M], h[N], e[M], idx; int dist[N], st[M]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } typedef pair&lt;int, int&gt; PII; void dijkstra() // æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯è·ç¦» { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } void dijkstra(int l, int r) { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); dist[n + 1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, n + 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (i2i[j].l &lt; l || i2i[j].l &gt; r) continue; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;P, &amp;L, &amp;X); Item item = {i, P, L}; for (int j = 1; j &lt;= X; j++) { scanf(&quot;%d%d&quot;, &amp;T, &amp;V); mp[T][i] = V; } i2i[i] = item; } // å»ºè¾¹ for (auto[k, v] : mp) { for (auto[k1, v1] : v) { if (abs(i2i[k1].l - i2i[k].l) &lt;= m) { add(k, k1, v1); } } } // è™šæ‹ŸèŠ‚ç‚¹ for (int i = 1; i &lt;= n; i++) add(n + 1, i, i2i[i].p); int ans = 0x3f3f3f3f; int le = i2i[1].l; for (int i = le - m; i &lt;= le; i++) { dijkstra(i, i + m); ans = min(ans, dist[1]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1135. æ–°å¹´å¥½ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;map&gt; using namespace std; const int N = 50010, M = 2e5 + 10, INF = 0x3f3f3f3f; int n, m, a, b, c, d, f; int ne[M], w[M], h[N], e[M], idx; int dist[6][N]; bool st[N]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } // void spfa(int distIdx, int S) { // auto &amp;dis = dist[distIdx]; // memset(st, 0, sizeof st); // memset(dis, 0x3f, sizeof dis); // queue&lt;int&gt; que; // que.push(S); // dis[S] = 0; // while(!que.empty()) { // int t = que.front(); // que.pop(); // st[t] = false; // for(int i=h[t];~i;i=ne[i]) { // int j = e[i]; // if(dis[t] + w[i] &lt; dis[j]) { // dis[j] = dis[t] + w[i]; // if(!st[j]) que.push(j), st[j] = true; // } // } // } // } typedef pair&lt;int, int&gt; PII; void dijkstra(int distIdx, int S) // æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯è·ç¦» { auto &amp;dis = dist[distIdx]; memset(dis, 0x3f, sizeof dis); memset(st, 0, sizeof st); dis[S] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, S}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dis[j] &gt; dis[ver] + w[i]) { dis[j] = dis[ver] + w[i]; heap.push({dis[j], j}); } } } } int main() { cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; f; memset(h, -1, sizeof h); for(int i=1;i&lt;=m;i++) { int a1, b1, c1; scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;b1, &amp;c1); add(a1, b1, c1), add(b1, a1, c1); } dijkstra(0, 1); dijkstra(1, a); dijkstra(2, b); dijkstra(3, c); dijkstra(4, d); dijkstra(5, f); vector&lt;int&gt; nums = {a, b, c, d, f}; sort(nums.begin(), nums.end()); unordered_map&lt;int, int&gt; mp; mp[a] = 1, mp[b] = 2, mp[c] = 3, mp[d] = 4, mp[f] = 5; int ans = INF; do { int t = dist[0][nums[0]]; for(int i=0;i&lt;4;i++) { t += dist[mp[nums[i]]][nums[i+1]]; } ans = min(ans, t); } while(next_permutation(nums.begin(), nums.end())); cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/tu-lun-dan-yuan-zui-duan-lu/"},{"title":"ã€DPã€‘æ•°ä½DP","content":" ç®—æ³•ä»‹ç» è¿™æ˜¯ä¸€ç±»å½¢å¼æ¯”è¾ƒå›ºå®šçš„DPé—®é¢˜ï¼Œå¾€å¾€æ˜¯æ±‚åœ¨æŸä¸ªåŒºé—´ [A, B] ä¸­æ»¡è¶³ç‰¹å®šæ¡ä»¶æ•°çš„ä¸ªæ•°ã€‚åšæ³•åŸºæœ¬ä¸Šæ˜¯ä¸‹é¢çš„ä¸€å¥—æ¨¡æ¿ã€‚ // è®¡ç®— 0 - x å†…æœ‰å¤šå°‘æ»¡è¶³æ¡ä»¶çš„æ•° int dp(int x) { // 0 ç‰¹åˆ¤ if(!x) return 0; // è®°å½•æ•°å­—xçš„å„ä½ä¸Šçš„æ•°å­— vector&lt;int&gt; nums; // B ä¸ºå¯¹åº”è¿›åˆ¶ï¼Œé€šå¸¸æ˜¯10è¿›åˆ¶ä¸‹çš„é—®é¢˜ while(x) nums.push_back(x % B), x /= B; // æœ€ç»ˆç­”æ¡ˆ int res = 0; // ä¸Šä¸€ä½æ•°çš„çŠ¶æ€ int last = 0; for(int i=nums.size()-1;i&gt;=0;i--) { int t = nums[i]; // do sth. if(!i) { // do sth. } } return res; } é€šå¸¸ï¼Œå¯¹äº i ä½ä¸Šçš„æ•°å­— k , [0, k-1ä¸Šçš„çŠ¶æ€æˆ‘ä»¬å¯ä»¥é€šè¿‡è¯¸å¦‚åŒºé—´DPæ–¹å¼æ±‚å‡ºæ¥ã€‚ ä¾‹é¢˜è®²è§£ ä¾‹é¢˜ åšæ³•æè¿° ä»£ç  AcWing 1081. åº¦çš„æ•°é‡ ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1082. æ•°å­—æ¸¸æˆ ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1083. Windyæ•° ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1084. æ•°å­—æ¸¸æˆ II ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1085. ä¸è¦62 ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1081. åº¦çš„æ•°é‡ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 32; LL f[N][N]; int X, Y, K, B; int dp(int x) { if (!x) return 0; vector&lt;int&gt; nums; while (x) nums.push_back(x % B), x /= B; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; if (t != 0) { if (t &gt; 1) { res += f[i + 1][K - last]; break; } else { res += f[i][K - last]; last++; if (last &gt; K) break; } } if (!i &amp;&amp; last == K) res++; } return res; } int main() { for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt;= i; j++) { if (j == 0) f[i][j] = 1; else f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; } } cin &gt;&gt; X &gt;&gt; Y &gt;&gt; K &gt;&gt; B; cout &lt;&lt; dp(Y) - dp(X - 1) &lt;&lt; endl; return 0; } ####AcWing 1082. æ•°å­—æ¸¸æˆ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1; else { for (int j = i; j &lt;= 9; j++) { f[i][len] += f[j][len - 1]; } } } } } int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if (last &gt; k) break; for (int j = last; j &lt; k; j++) { res += f[j][i + 1]; } last = k; if (!i) res++; } return res; } int main() { init(); // cout &lt;&lt; f[2][2] &lt;&lt; endl; while (cin &gt;&gt; a &gt;&gt; b) { cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } AcWing 1083. Windyæ•° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N], g[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1, g[i][len] = 1; else { for (int j = 0; j &lt;= 9; j++) { if (abs(j - i) &gt;= 2) { f[i][len] += f[j][len - 1]; } } if (i == 0) { for (int j = 0; j &lt;= 9; j++) { g[0][len] += g[j][len - 1]; } } else { g[i][len] = f[i][len]; } } } } } int dp(int x) { if (x &gt;= 0 &amp;&amp; x &lt;= 9) return x + 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = -2; bool flag = false; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if(k != 0) { if (!flag) { res += g[0][i + 1]; } else if (abs(last) &gt;= 2) { res += f[0][i + 1]; } for (int j = 1; j &lt; k; j++) { if (abs(last - j) &gt;= 2) { res += f[j][i + 1]; } } } if (abs(last - k) &lt;= 1) break; last = k; if (k != 0) flag = true; if (!i) res++; } return res; } int main() { init(); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; return 0; } ####AcWing 1084. æ•°å­—æ¸¸æˆ II #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N][105]; int mod; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) { f[i][len][i % mod] = 1; continue; } for (int j = 0; j &lt; mod; j++) { for (int k = 0; k &lt;= 9; k++) { f[i][len][j] += f[k][len - 1][((j - i) % mod + mod) % mod]; } } } } } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; for (int j = 0; j &lt; k; j++) { res += f[j][i + 1][((mod - last) % mod + mod) % mod]; } last = (last + k) % mod; if (!n &amp;&amp; last % mod == 0) res++; } return res; } int main() { while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod) { memset(f, 0, sizeof(f)); init(); cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } ####AcWing 1085. ä¸è¦62 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (i == 4) continue; if (len == 1) f[i][len] = 1; else { if (i == 6) for (int j = 0; j &lt;= 9; j++) { if (j == 2 || j== 4) continue; f[i][len] += f[j][len - 1]; } else { for (int j = 0; j &lt;= 9; j++) { if(j == 4) continue; f[i][len] += f[j][len - 1]; } } } } } } int n, m; int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int last = 0, res = 0; // res += f[0][nums.size()]; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; for (int j = 0; j &lt; t; j++) { // if(i == nums.size() - 1&amp;&amp; j == 0) continue; if(last == 6 &amp;&amp; j == 2) continue; if(j == 4) continue; res += f[j][i+1]; } if(t == 4) break; if(last == 6 &amp;&amp; t == 2) break; last = t; if(!i) res++; } return res; } int main() { init(); while (cin &gt;&gt; n &gt;&gt; m, !(n == 0 &amp;&amp; m == 0)) { cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; endl; } return 0; } ","link":"https://tofindmore.github.io/post/dp-shu-wei-dp/"},{"title":"ã€DPã€‘çŠ¶æ€å‹ç¼©","content":" ç®—æ³•ä»‹ç» è¿™æ˜¯ä¸€ç±»æŠŠé›†åˆè½¬åŒ–ä¸ºæ•´æ•°è®°å½•åœ¨DPçŠ¶æ€ä¸­çš„ç®—æ³•ã€‚å‡è®¾ 1 ä»£è¡¨æŒæœ‰æŸç§çŠ¶æ€ï¼Œé‚£ä¹ˆå¯¹äºåè¿›åˆ¶æ•° (11)D = (1011)B æ¥è¯´å¯ä»¥è¡¨ç¤ºä¸ºæŒæœ‰ç¬¬ 4 2 1 3ç§çŠ¶æ€ã€‚ å¦‚ä¸‹æ˜¯ num æ‰€æŒæœ‰çš„çŠ¶æ€çš„æ‰€æœ‰å­é›†ï¼ˆåŒ…å«ç©ºé›†ï¼‰ã€‚ int sub = num; do { // do sth sub = num &amp; (sub - 1); } while(sub != num) é€šè¿‡å­é›†é¢„å¤„ç†ï¼Œå¯ä»¥å‡å°‘æšä¸¾çŠ¶æ€å’Œä¸€ç³»åˆ—å¤šä½™çŠ¶æ€çš„åˆ¤æ–­ ä¾‹é¢˜è®²è§£ 1. æ£‹ç›˜ç±»é—®é¢˜ï¼ˆåŸºäºè¿é€šæ€§çš„DPï¼‰ æ£‹ç›˜ç±»é—®é¢˜éœ€è¦æƒ³æ¸…æ¥šå±‚ä¸å±‚ä¹‹é—´çš„çŠ¶æ€è½¬ç§»å…³ç³»ï¼Œé€šå¸¸æ˜¯ä»¥ dp[i][s1] ï½ dp[i-1][s2] è¡¨ç¤ºç¬¬ i å±‚çŠ¶æ€ s1 æ˜¯ç”± i-1 å±‚çŠ¶æ€è½¬ç§»è€Œæ¥ï¼Œæœ‰æ—¶ä¼šç‰µæ‰¯åˆ°ä¸‰å±‚ä¹‹é—´çš„å…³ç³»ï¼Œå³ dp[i][s1] ï½ dp[i-1][s2] and dp[i-2][s3] æœ¬ç«™ç›¸å…³ä¾‹é¢˜è®²è§£ ä¾‹é¢˜ åšæ³•æè¿° ä»£ç  AcWing 1064. å°å›½ç‹ dp[i][j][k]è¡¨ç¤ºç¬¬iè¡ŒçŠ¶æ€ä¸ºkä¸”å‰iè¡Œå…±å¯ä»¥æ”¾jä¸ªå›½ç‹ ğŸ”— AcWing 327. ç‰ç±³ç”° dp[i][s] è¡¨ç¤ºç¬¬iå±‚å‹ç¼©çŠ¶æ€ä½sçš„æ€»ç§æ³• ğŸ”— AcWing 292. ç‚®å…µé˜µåœ° æ»šåŠ¨æ•°ç»„ + dp[i][j][k]è¡¨ç¤ºç¬¬iå±‚çŠ¶æ€jï¼Œi-1å±‚çŠ¶æ€ä¸ºk ğŸ”— 2. é›†åˆç±»é—®é¢˜ // TODO AcWing 1064. å°å›½ç‹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; int n, m; vector&lt;int&gt; stateVec, head[2000]; LL dp[12][110][2000]; int cnt[2000]; bool check(int state) { for (int i = 0; i &lt; n; i++) { if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int count(int state) { int cnt = 0; for (int i = 0; i &lt; n; i++) if (state &gt;&gt; i &amp; 1) ++cnt; return cnt; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) if (check(i)) stateVec.push_back(i), cnt[i] = count(i); for (int i = 0; i &lt; stateVec.size(); i++) { for (int j = 0; j &lt; stateVec.size(); j++) { int a = stateVec[i], b = stateVec[j]; if (!(a &amp; b) &amp;&amp; check(a | b)) { head[a].push_back(b); } } } dp[0][0][0] = 1; for (int i = 1; i &lt;= n + 1; i++) { for (int j = 0; j &lt;= m; j++) { for (int k = 0; k &lt; stateVec.size(); k++) { int a = stateVec[k]; for (int t = 0; t &lt; head[a].size(); t++) { int c = cnt[a]; if (j &gt;= c) dp[i][j][a] += dp[i - 1][j - c][head[a][t]]; } } } } cout &lt;&lt; dp[n + 1][m][0] &lt;&lt; endl; return 0; } AcWing 327. ç‰ç±³ç”° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1 &lt;&lt; 13 + 10; const int M = 14, MOD = 1e8; int n, m, t; int id[M]; long long dp[M][N]; bool check(int s) { for (int i = 0; i &lt; m; i++) { if ((s &gt;&gt; i &amp; 1) &amp;&amp; (s &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; t; id[i] = (id[i] &lt;&lt; 1) + t; } } dp[0][0] = 1; long long ans = 0; for (int i = 1; i &lt;= n; i++) { int pre = id[i - 1], cur = id[i]; int s1 = cur; do { int s2 = pre; do { if (check(s1) &amp;&amp; check(s2) &amp;&amp; (s1 &amp; s2) == 0) { dp[i][s1] = (dp[i][s1] + dp[i - 1][s2]) % MOD; } s2 = (s2 - 1) &amp; pre; } while (s2 != pre); if (i == n) ans = (ans + dp[i][s1]) % MOD; s1 = (s1 - 1) &amp; cur; } while (s1 != cur); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 292. ç‚®å…µé˜µåœ° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 110; const int M = 1 &lt;&lt; 10; int n, m; vector&lt;int&gt; id(N); int dp[2][M][M]; bool check(int s) { for (int i = 0; i &lt; m; i++) { int t = ((s &gt;&gt; i) &amp; 1) + ((s &gt;&gt; (i + 1)) &amp; 1) + ((s &gt;&gt; (i + 2)) &amp; 1); if (t &gt;= 2) return false; } return true; } int count(int s) { int ret = 0; for (int i = 0; i &lt;= m; i++) { if (s &gt;&gt; i &amp; 1) ret++; } return ret; } int main() { cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; head[N]; head[0].push_back(0); head[1].push_back(0); for (int i = 2; i &lt;= n + 1; i++) { for (int j = 0; j &lt; m; j++) { char c; cin &gt;&gt; c; id[i] = (id[i] &lt;&lt; 1) + (c == 'P'); } int s = id[i]; do { if (check(s)) head[i].push_back(s); s = (s - 1) &amp; id[i]; } while (s != id[i]); } int turn = 1; int ans = 0; for (int i = 2; i &lt;= n + 1; i++) { turn ^= 1; for (int j = 0; j &lt; head[i].size(); j++) { for (int k = 0; k &lt; head[i - 1].size(); k++) { for (int v = 0; v &lt; head[i - 2].size(); v++) { int c = head[i][j], p = head[i - 1][k], pp = head[i - 2][v]; if (((c &amp; p) == 0) &amp;&amp; ((pp &amp; p) == 0) &amp;&amp; ((pp &amp; c) == 0)) { dp[turn][c][p] = max(dp[turn ^ 1][p][pp] + count(c), dp[turn][c][p]); ans = max(ans, dp[turn][c][p]); } } } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/dp-zhuan-ti-zhuang-tai-ya-suo/"}]}