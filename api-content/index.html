{"posts":[{"title":"【图论】单源最短路","content":" 图的存储 对于有向图而言，有两种方式的图存储方式 邻接表 对于邻接表而言，推荐采用链式前向星数组的形式， 增加节点和便利节点的方式如下 // e[i] : 代表另外一个端点 // nxt[i] : 同一个链表下的下一个索引 // w[i] : 边长 // h[i] : 指向端点i的头节点 // idx : 下一条边的索引 int e[M], nxt[M], w[M], h[N], idx; // 一些初始化 void init() { // 刚开始所有的点都指向 -1 memset(h, -1, sizeof h); } // 添加a指向b且长度为c的有向边 void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } // 遍历 void demo { int cur = 1; for(int i=h[cur];i!=-1;i=nxt[i]) { // 另外一边 int k = e[i]; // .... } } 邻接矩阵 对于二维数组 g[i][j] 表示点 i 指向 j 存在 g[i][j] 长度的有向边 最短路算法 1. Dijkstra 这个算法采用了贪心策略，在每次可以遍历可以确定一个最优点 朴素的Dij 复杂度是 O(n2n^2n2)，n 是点数 朴素算法的瓶颈在于找出全局最小点，堆优化Dij采用最小堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;来对 dist[i] 维护，时间复杂度是 O(mlognmlognmlogn) ，其中m是边的个数 代码模板（朴素） const int N = 2021; int d[N][N], dist[N]; bool st[N]; // 使用的是邻接矩阵 void dijkstra() { dist[S] = 0; for (int i = 1; i &lt;= n; i++) { int cur = -1; // 找最小的那个（前提是这个边没有被找过） for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &gt; dist[j])) cur = j; st[cur] = true; // 更新最小点周围的边长 for (int j = 1; j &lt;= n; j++) if (dist[cur] + d[cur][j] &lt; dist[j]) dist[j] = dist[cur] + d[cur][j]; } } 代码模板（堆优化） typedef pair&lt;int, int&gt; PII; int dist[N], st[M]; // 使用的是邻接表 void dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 定义最小堆 priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; // 如果改节已被确定，则无需再进行相邻点更新 if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } 2. SPFA（Shortest Path Fast Algorithm） 这个算法是广搜的变形，很明显，当路径长度为1的时候，我们可以用BFS来算最短路。 这个算法在随机图上的时间复杂度是O(kmkmkm), k是一个很小的常数，对于特殊图，可能会达到O(​mnmnmn) 的时间复杂度。 这个算法是可以处理负权边的 代码模板 // 起始点 S int dist[N], S; bool st[N]; // 使用的是邻接表 void spfa() { queue&lt;int&gt; que; que.push(S); dist[u] = 0, st[S] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; // 遍历所有相邻节点 for (int i = h[cur]; i != -1; i = ne[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; // 如果不在队列中，则加入队列 if (st[k] == 0) que.push(k); } } } } 3. Floyd（多源） 这个算法可以通过O(n3n^3n3)的时间复杂度算出任意两个点的最短路，是一种dp思路。 代码模板 int dist[N][N]; void floyd() { for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } 例题讲解 例题 做法描述 代码 AcWing 1129. 热浪 直接一遍spfa既可，也可以用dijkstra 🔗 AcWing 1128. 信使 数据量不大，可以直接一遍floyd，算出距离起点到各点之间的最短路长度的最大值 🔗 AcWing 1127. 香甜的黄油 对各节点进行一遍spfa，然后将各奶牛到该节点的最短路径相加取最小既可 🔗 AcWing 1126. 最小花费 乘法最大值（权值小于1），dijkstra修改为乘法的最短路，可以用log来证明其使用最短路 🔗 AcWing 920. 最优乘车 最小换乘，将单程链中每个节点的前驱都指向该节点，变成了最短路问题，答案就是最短路长度 - 1 🔗 AcWing 903. 昂贵的聘礼 建立一个虚拟节点， 注意所有交易链路的等级最小值和最大值不能超过M，用朴素dij暴力所有等级区间既可 🔗 AcWing 1129. 热浪 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; const int N = 2510, M = 6210 &lt;&lt; 1; int start, en, n, m; int e[M], nxt[M], w[M], h[N], idx; int dist[N], st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } void spfa(int u) { queue&lt;int&gt; que; que.push(u); dist[u] = 0, st[u] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; for (int i = h[cur]; i != -1; i = nxt[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; if (st[k] == 0) que.push(k); } } } } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; en; memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= m; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c), add(b, a, c); } spfa(start); cout &lt;&lt; dist[en] &lt;&lt; endl; return 0; } AcWing 1128. 信使 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m; const int N = 110, INF = 0x3f3f3f3f; int dist[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= n; i++) dist[i][i] = 0; for (int i = 1; i &lt;= m; i++) { int p1, p2, dis; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis; dist[p1][p2] = dist[p2][p1] = min(dist[p1][p2], dis); } for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); int ans = -1; for (int i = 1; i &lt;= n; i++) { if (dist[1][i] == INF) { ans = -1; break; } ans = max(ans, dist[1][i]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1127. 香甜的黄油 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, p, c; const int N = 810, M = 510, T = 1510 * 2, INF = 0x3f3f3f3f; int r[N], dist[T]; bool st[T]; int ne[T], w[T], e[T], h[N], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void spfa(int S) { memset(st, 0, sizeof st); memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; que.push(S); dist[S] = 0; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (dist[u] + w[i] &lt; dist[j]) { dist[j] = dist[u] + w[i]; if (!st[j]) que.push(j), st[j] = true; } } } } int main() { cin &gt;&gt; n &gt;&gt; p &gt;&gt; c; memset(h, -1, sizeof h); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; r[i]; for (int i = 1; i &lt;= c; i++) { int a, b, wi; cin &gt;&gt; a &gt;&gt; b &gt;&gt; wi; add(a, b, wi), add(b, a, wi); } int ans = INF; for (int i = 1; i &lt;= p; i++) { spfa(i); int sum = 0, j = 1; for (; j &lt;= n; j++) { if (dist[r[j]] == INF) break; sum += dist[r[j]]; } if (j &lt;= n) continue; ans = min(ans, sum); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1126. 最小花费 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m, S, T; const int N = 2010, INF = 0x3f3f3f3f; double d[N][N], dist[N]; bool st[N]; double dijkstra() { dist[S] = 1.0; for (int i = 1; i &lt;= n; i++) { int cur = -1; for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &lt; dist[j])) cur = j; st[cur] = true; for (int j = 1; j &lt;= n; j++) if (dist[cur] * d[cur][j] &gt; dist[j]) dist[j] = dist[cur] * d[cur][j]; } return dist[T]; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; N; i++) d[i][i] = 1; for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); d[x][y] = d[y][x] = (100.0 - z * 1.0) / 100.0; } cin &gt;&gt; S &gt;&gt; T; printf(&quot;%.8lf\\n&quot;, 100.0 / dijkstra()); return 0; } AcWing 920. 最优乘车 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;sstream&gt; #include &lt;queue&gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int g[N][N], dist[N], stop[N]; bool st[N]; int n, m; void spfa() { memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; dist[1] = 0; que.push(1); st[1] = true; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = 1; i &lt;= n; i++) { if (g[u][i] + dist[u] &lt; dist[i]) { dist[i] = g[u][i] + dist[u]; if (!st[i]) que.push(i); } } } } int main() { memset(g, 0x3f, sizeof g); for (int i = 0; i &lt; N; i++) g[i][i] = 0; cin &gt;&gt; m &gt;&gt; n; string line; getline(cin, line); while (m--) { getline(cin, line); stringstream ssin(line); int cnt = 0, p; while (ssin &gt;&gt; p) stop[cnt++] = p; for (int i = 0; i &lt; cnt; i++) for (int j = i + 1; j &lt; cnt; j++) g[stop[i]][stop[j]] = 1; } spfa(); if (dist[n] == INF) puts(&quot;NO&quot;); else cout &lt;&lt; max(0, dist[n] - 1) &lt;&lt; endl; return 0; } AcWing 903. 昂贵的聘礼 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, m; int P, L, X; int T, V; const int N = 110, M = 110 * 110; struct Item { int id, p, l; }; unordered_map&lt;int, Item&gt; i2i; unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; mp; int ne[M], w[M], h[N], e[M], idx; int dist[N], st[M]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } typedef pair&lt;int, int&gt; PII; void dijkstra() // 求1号点到n号点的最短路距离 { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } void dijkstra(int l, int r) { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); dist[n + 1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, n + 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (i2i[j].l &lt; l || i2i[j].l &gt; r) continue; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;P, &amp;L, &amp;X); Item item = {i, P, L}; for (int j = 1; j &lt;= X; j++) { scanf(&quot;%d%d&quot;, &amp;T, &amp;V); mp[T][i] = V; } i2i[i] = item; } // 建边 for (auto[k, v] : mp) { for (auto[k1, v1] : v) { if (abs(i2i[k1].l - i2i[k].l) &lt;= m) { add(k, k1, v1); } } } // 虚拟节点 for (int i = 1; i &lt;= n; i++) add(n + 1, i, i2i[i].p); int ans = 0x3f3f3f3f; int le = i2i[1].l; for (int i = le - m; i &lt;= le; i++) { dijkstra(i, i + m); ans = min(ans, dist[1]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/tu-lun-dan-yuan-zui-duan-lu/"},{"title":"【DP】数位DP","content":" 算法介绍 这是一类形式比较固定的DP问题，往往是求在某个区间 [A, B] 中满足特定条件数的个数。做法基本上是下面的一套模板。 // 计算 0 - x 内有多少满足条件的数 int dp(int x) { // 0 特判 if(!x) return 0; // 记录数字x的各位上的数字 vector&lt;int&gt; nums; // B 为对应进制，通常是10进制下的问题 while(x) nums.push_back(x % B), x /= B; // 最终答案 int res = 0; // 上一位数的状态 int last = 0; for(int i=nums.size()-1;i&gt;=0;i--) { int t = nums[i]; // do sth. if(!i) { // do sth. } } return res; } 通常，对于 i 位上的数字 k , [0, k-1上的状态我们可以通过诸如区间DP方式求出来。 例题讲解 例题 做法描述 代码 AcWing 1081. 度的数量 直接看代码 🔗 AcWing 1082. 数字游戏 直接看代码 🔗 AcWing 1083. Windy数 直接看代码 🔗 AcWing 1084. 数字游戏 II 直接看代码 🔗 AcWing 1085. 不要62 直接看代码 🔗 AcWing 1081. 度的数量 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 32; LL f[N][N]; int X, Y, K, B; int dp(int x) { if (!x) return 0; vector&lt;int&gt; nums; while (x) nums.push_back(x % B), x /= B; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; if (t != 0) { if (t &gt; 1) { res += f[i + 1][K - last]; break; } else { res += f[i][K - last]; last++; if (last &gt; K) break; } } if (!i &amp;&amp; last == K) res++; } return res; } int main() { for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt;= i; j++) { if (j == 0) f[i][j] = 1; else f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; } } cin &gt;&gt; X &gt;&gt; Y &gt;&gt; K &gt;&gt; B; cout &lt;&lt; dp(Y) - dp(X - 1) &lt;&lt; endl; return 0; } ####AcWing 1082. 数字游戏 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1; else { for (int j = i; j &lt;= 9; j++) { f[i][len] += f[j][len - 1]; } } } } } int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if (last &gt; k) break; for (int j = last; j &lt; k; j++) { res += f[j][i + 1]; } last = k; if (!i) res++; } return res; } int main() { init(); // cout &lt;&lt; f[2][2] &lt;&lt; endl; while (cin &gt;&gt; a &gt;&gt; b) { cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } AcWing 1083. Windy数 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N], g[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1, g[i][len] = 1; else { for (int j = 0; j &lt;= 9; j++) { if (abs(j - i) &gt;= 2) { f[i][len] += f[j][len - 1]; } } if (i == 0) { for (int j = 0; j &lt;= 9; j++) { g[0][len] += g[j][len - 1]; } } else { g[i][len] = f[i][len]; } } } } } int dp(int x) { if (x &gt;= 0 &amp;&amp; x &lt;= 9) return x + 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = -2; bool flag = false; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if(k != 0) { if (!flag) { res += g[0][i + 1]; } else if (abs(last) &gt;= 2) { res += f[0][i + 1]; } for (int j = 1; j &lt; k; j++) { if (abs(last - j) &gt;= 2) { res += f[j][i + 1]; } } } if (abs(last - k) &lt;= 1) break; last = k; if (k != 0) flag = true; if (!i) res++; } return res; } int main() { init(); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; return 0; } ####AcWing 1084. 数字游戏 II #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N][105]; int mod; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) { f[i][len][i % mod] = 1; continue; } for (int j = 0; j &lt; mod; j++) { for (int k = 0; k &lt;= 9; k++) { f[i][len][j] += f[k][len - 1][((j - i) % mod + mod) % mod]; } } } } } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; for (int j = 0; j &lt; k; j++) { res += f[j][i + 1][((mod - last) % mod + mod) % mod]; } last = (last + k) % mod; if (!n &amp;&amp; last % mod == 0) res++; } return res; } int main() { while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod) { memset(f, 0, sizeof(f)); init(); cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } ####AcWing 1085. 不要62 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (i == 4) continue; if (len == 1) f[i][len] = 1; else { if (i == 6) for (int j = 0; j &lt;= 9; j++) { if (j == 2 || j== 4) continue; f[i][len] += f[j][len - 1]; } else { for (int j = 0; j &lt;= 9; j++) { if(j == 4) continue; f[i][len] += f[j][len - 1]; } } } } } } int n, m; int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int last = 0, res = 0; // res += f[0][nums.size()]; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; for (int j = 0; j &lt; t; j++) { // if(i == nums.size() - 1&amp;&amp; j == 0) continue; if(last == 6 &amp;&amp; j == 2) continue; if(j == 4) continue; res += f[j][i+1]; } if(t == 4) break; if(last == 6 &amp;&amp; t == 2) break; last = t; if(!i) res++; } return res; } int main() { init(); while (cin &gt;&gt; n &gt;&gt; m, !(n == 0 &amp;&amp; m == 0)) { cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; endl; } return 0; } ","link":"https://tofindmore.github.io/post/dp-shu-wei-dp/"},{"title":"【DP】状态压缩","content":" 算法介绍 这是一类把集合转化为整数记录在DP状态中的算法。假设 1 代表持有某种状态，那么对于十进制数 (11)D = (1011)B 来说可以表示为持有第 4 2 1 3种状态。 如下是 num 所持有的状态的所有子集（包含空集）。 int sub = num; do { // do sth sub = num &amp; (sub - 1); } while(sub != num) 通过子集预处理，可以减少枚举状态和一系列多余状态的判断 例题讲解 1. 棋盘类问题（基于连通性的DP） 棋盘类问题需要想清楚层与层之间的状态转移关系，通常是以 dp[i][s1] ～ dp[i-1][s2] 表示第 i 层状态 s1 是由 i-1 层状态转移而来，有时会牵扯到三层之间的关系，即 dp[i][s1] ～ dp[i-1][s2] and dp[i-2][s3] 本站相关例题讲解 例题 做法描述 代码 AcWing 1064. 小国王 dp[i][j][k]表示第i行状态为k且前i行共可以放j个国王 🔗 AcWing 327. 玉米田 dp[i][s] 表示第i层压缩状态位s的总种法 🔗 AcWing 292. 炮兵阵地 滚动数组 + dp[i][j][k]表示第i层状态j，i-1层状态为k 🔗 2. 集合类问题 // TODO AcWing 1064. 小国王 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; int n, m; vector&lt;int&gt; stateVec, head[2000]; LL dp[12][110][2000]; int cnt[2000]; bool check(int state) { for (int i = 0; i &lt; n; i++) { if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int count(int state) { int cnt = 0; for (int i = 0; i &lt; n; i++) if (state &gt;&gt; i &amp; 1) ++cnt; return cnt; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) if (check(i)) stateVec.push_back(i), cnt[i] = count(i); for (int i = 0; i &lt; stateVec.size(); i++) { for (int j = 0; j &lt; stateVec.size(); j++) { int a = stateVec[i], b = stateVec[j]; if (!(a &amp; b) &amp;&amp; check(a | b)) { head[a].push_back(b); } } } dp[0][0][0] = 1; for (int i = 1; i &lt;= n + 1; i++) { for (int j = 0; j &lt;= m; j++) { for (int k = 0; k &lt; stateVec.size(); k++) { int a = stateVec[k]; for (int t = 0; t &lt; head[a].size(); t++) { int c = cnt[a]; if (j &gt;= c) dp[i][j][a] += dp[i - 1][j - c][head[a][t]]; } } } } cout &lt;&lt; dp[n + 1][m][0] &lt;&lt; endl; return 0; } AcWing 327. 玉米田 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1 &lt;&lt; 13 + 10; const int M = 14, MOD = 1e8; int n, m, t; int id[M]; long long dp[M][N]; bool check(int s) { for (int i = 0; i &lt; m; i++) { if ((s &gt;&gt; i &amp; 1) &amp;&amp; (s &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; t; id[i] = (id[i] &lt;&lt; 1) + t; } } dp[0][0] = 1; long long ans = 0; for (int i = 1; i &lt;= n; i++) { int pre = id[i - 1], cur = id[i]; int s1 = cur; do { int s2 = pre; do { if (check(s1) &amp;&amp; check(s2) &amp;&amp; (s1 &amp; s2) == 0) { dp[i][s1] = (dp[i][s1] + dp[i - 1][s2]) % MOD; } s2 = (s2 - 1) &amp; pre; } while (s2 != pre); if (i == n) ans = (ans + dp[i][s1]) % MOD; s1 = (s1 - 1) &amp; cur; } while (s1 != cur); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 292. 炮兵阵地 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 110; const int M = 1 &lt;&lt; 10; int n, m; vector&lt;int&gt; id(N); int dp[2][M][M]; bool check(int s) { for (int i = 0; i &lt; m; i++) { int t = ((s &gt;&gt; i) &amp; 1) + ((s &gt;&gt; (i + 1)) &amp; 1) + ((s &gt;&gt; (i + 2)) &amp; 1); if (t &gt;= 2) return false; } return true; } int count(int s) { int ret = 0; for (int i = 0; i &lt;= m; i++) { if (s &gt;&gt; i &amp; 1) ret++; } return ret; } int main() { cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; head[N]; head[0].push_back(0); head[1].push_back(0); for (int i = 2; i &lt;= n + 1; i++) { for (int j = 0; j &lt; m; j++) { char c; cin &gt;&gt; c; id[i] = (id[i] &lt;&lt; 1) + (c == 'P'); } int s = id[i]; do { if (check(s)) head[i].push_back(s); s = (s - 1) &amp; id[i]; } while (s != id[i]); } int turn = 1; int ans = 0; for (int i = 2; i &lt;= n + 1; i++) { turn ^= 1; for (int j = 0; j &lt; head[i].size(); j++) { for (int k = 0; k &lt; head[i - 1].size(); k++) { for (int v = 0; v &lt; head[i - 2].size(); v++) { int c = head[i][j], p = head[i - 1][k], pp = head[i - 2][v]; if (((c &amp; p) == 0) &amp;&amp; ((pp &amp; p) == 0) &amp;&amp; ((pp &amp; c) == 0)) { dp[turn][c][p] = max(dp[turn ^ 1][p][pp] + count(c), dp[turn][c][p]); ans = max(ans, dp[turn][c][p]); } } } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/dp-zhuan-ti-zhuang-tai-ya-suo/"}]}