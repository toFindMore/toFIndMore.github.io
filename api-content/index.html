{"posts":[{"title":"ã€æ•°å­¦çŸ¥è¯†ã€‘ ä¸€ã€è´¨æ•°ä¸çº¦æ•°","content":"è´¨æ•° è¯•é™¤æ³•ï¼Œåˆ¤å®šnæ˜¯å¦æ˜¯è´¨æ•°ï¼Œæ—¶é—´å¤æ‚åº¦ O(N*SQRT(N)) // å°±æ˜¯ä¸€ä¸ª2åˆ°sqrt(n)çš„éå† bool isPrime(int n) { if (n &lt;= 1) return false; for (int i = 2; i &lt;= n / i; i++) if (n % i == 0) return false; return true; } çº¿æ€§ç­›æ³• int primes[N], cnt; // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•° bool st[N]; // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰ // çº¿æ€§ç­›çš„åŸç†æ˜¯åŸºäºåŸƒå¼ç­›ï¼Œé¿å…é‡å¤ç­›çš„æƒ…å†µï¼Œå®šä¹‰ä¸€ä¸ªåˆæ•°ä¸€å®šæ˜¯è¢«å…¶æœ€å°è´¨å› å­ç­›å»çš„ void getPrimes(int n) { for (int i = 2; i &lt;= n; i++) { if (!st[i]) primes[cnt++] = i; // ï¼ˆ1ï¼‰. å¦‚æœ i % primes[j] == 0ï¼Œ é‚£ä¹ˆ primes[j] ä¸€å®šæ˜¯ i æœ€å°è´¨å› å­ // ï¼ˆ2ï¼‰. åœ¨ ï¼ˆ1ï¼‰ æ²¡æœ‰å‘ç”Ÿçš„æ—¶å€™ï¼Œprimes[j] * i çš„æœ€å°è´¨å› å­ä¸€å®šæ˜¯ primes[j]ï¼Œæ­¤æ—¶ i è¿˜æ²¡æ‰¾åˆ°è‡ªå·±çš„æœ€å°è´¨å› å­ // ï¼ˆ3ï¼‰æ‰€æœ‰åˆæ•°éƒ½æœ‰è‡ªå·±çš„æœ€å°è´¨å› å­ï¼Œæ‰€ä»¥ä¸€å®šä¼šè¢«ç­› for (int j = 0; primes[j] &lt;= n / i; j++) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } åˆ†è§£è´¨å› æ•° åˆ†è§£è´¨å› æ•° void divide(int n) { for (int i = 2; i &lt;= n / i; i++) { if (n % i == 0) { // æ­¤æ—¶ i ä¸€å®šæ˜¯è´¨æ•° int cnt = 0; while (n % i == 0) { cnt++; n /= i; } // æœ‰ cnt ä¸ª i printf(&quot;%d %d\\n&quot;, i, cnt); } } // å¤§äº sqrt(n) çš„æ•° if (n &gt; 1) printf(&quot;%d 1\\n&quot;, n); puts(&quot;&quot;); } çº¦æ•° åŸºæœ¬å®šç†ï¼šä»»ä½•ä¸€ä¸ªå¤§äº 11 çš„è‡ªç„¶æ•° NN ï¼Œå¦‚æœ N ä¸ä¸ºè´¨æ•°ï¼Œé‚£ä¹ˆ N å¯ä»¥å”¯ä¸€åˆ†è§£æˆæœ‰é™ä¸ªè´¨æ•°çš„ä¹˜ç§¯ N=P1a1P2a2P3a3......PnanN=P^{a_1}_1P^{a_2}_2P^{a_3}_3......P^{a_n}_nN=P1a1â€‹â€‹P2a2â€‹â€‹P3a3â€‹â€‹......Pnanâ€‹â€‹ï¼Œè¿™é‡Œ P1&lt;P2&lt;P3......&lt;PnP_1&lt;P_2&lt;P_3......&lt;P_nP1â€‹&lt;P2â€‹&lt;P3â€‹......&lt;Pnâ€‹ å‡ä¸ºè´¨æ•°ï¼Œå…¶ä¸­æŒ‡æ•° aiaiai æ˜¯æ­£æ•´æ•°ã€‚ çº¦æ•°ä¸ªæ•°ï¼š(a1+1)âˆ—(a2+1)âˆ—...âˆ—(an+1)(a_1 + 1) * (a_2 + 1)* ... * (a_n + 1)(a1â€‹+1)âˆ—(a2â€‹+1)âˆ—...âˆ—(anâ€‹+1) çº¦æ•°ä¹‹å’Œï¼š(P10+P12+â€¦+P1a1)âˆ—â€¦âˆ—(Pn0+Pn2+â€¦+Pna1)(P_{1}^{0}+P_{1}^{2}+â€¦+P_{1}^{a1})âˆ—â€¦âˆ—(P_{n}^{0}+P_{n}^{2}+â€¦+P_{n}^{a1})(P10â€‹+P12â€‹+â€¦+P1a1â€‹)âˆ—â€¦âˆ—(Pn0â€‹+Pn2â€‹+â€¦+Pna1â€‹) // n ä¸ªæ­£æ•´æ•° ai, è¯·ä½ è¾“å‡ºè¿™äº›æ•°çš„ä¹˜ç§¯çš„çº¦æ•°ä¸ªæ•° #include &lt;iostream&gt; #include &lt;unordered_map&gt; using namespace std; const int m = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n--) { int k; cin &gt;&gt; k; for (int i = 2; i &lt;= k / i; i++) { while (k % i == 0) { primes[i]++; k /= i; } } if (k &gt; 1) primes[k]++; } long long ans = 1; for (auto[k, v] : primes) ans = ans * (v + 1) % m; cout &lt;&lt; ans &lt;&lt; endl; return 0; } // n ä¸ªæ­£æ•´æ•° aiï¼Œè¯·ä½ è¾“å‡ºè¿™äº›æ•°çš„ä¹˜ç§¯çš„çº¦æ•°ä¹‹å’Œï¼Œ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n--) { int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i++) while (x % i == 0) { x /= i; primes[i]++; } if (x &gt; 1) primes[x]++; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b--) t = (t * a + 1) % mod; res = res * t % mod; } cout &lt;&lt; res &lt;&lt; endl; return 0; } æœ€å¤§å…¬çº¦æ•° æ¬§å‡ é‡Œå¾—ç®—æ³•åˆç§°è¾—è½¬ç›¸é™¤æ³•ï¼Œæ˜¯æŒ‡ç”¨äºè®¡ç®—ä¸¤ä¸ªéè´Ÿæ•´æ•°éè´Ÿæ•´æ•°aï¼Œbçš„æœ€å¤§å…¬çº¦æ•°ã€‚åº”ç”¨é¢†åŸŸæœ‰æ•°å­¦å’Œè®¡ç®—æœºä¸¤ä¸ªæ–¹é¢ã€‚è®¡ç®—å…¬å¼ gcd(a,b)=gcd(b,aMODb)gcd(a,b) = gcd(b,a MOD b)gcd(a,b)=gcd(b,aMODb)ã€‚ int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } ","link":"https://tofindmore.github.io/post/shu-xue-zhi-shi-1-zhi-shu-yu-yue-shu/"},{"title":"ã€æ•°æ®ç»“æ„ã€‘çº¿æ®µæ ‘","content":"1.çº¿æ®µæ ‘åŸºæœ¬ä»‹ç»ä¸å®ç° æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ç§åŸºäºåˆ†æ²»æ€æƒ³çš„äºŒå‰æ ‘ç»“æ„ï¼Œç”¨äºåœ¨åŒºé—´ä¸Šè¿›è¡Œä¿¡æ¯ç»Ÿè®¡ï¼Œä¸æŒ‰ç…§äºŒè¿›åˆ¶ä½è¿›è¡ŒåŒºé—´åˆ’åˆ†çš„æ ‘çŠ¶æ•°ç»„ç›¸æ¯”ï¼Œçº¿æ®µæ ‘æ›´åŠ é€šç”¨ï¼š çº¿æ®µæ ‘æ¯ä¸ªèŠ‚ç‚¹éƒ½ä»£è¡¨ä¸€ä¸ªåŒºé—´ çº¿æ®µæ ‘å…·æœ‰å”¯ä¸€çš„æ ¹èŠ‚ç‚¹ï¼Œä»£è¡¨çš„åŒºé—´æ˜¯æ•´ä¸ªç»Ÿè®¡èŒƒå›´ï¼Œå¦‚ [1,N][1, N][1,N] çº¿æ®µæ ‘çš„æ¯ä¸ªå¶å­èŠ‚ç‚¹éƒ½ä»£è¡¨ä¸€ä¸ªé•¿åº¦ä¸º1çš„å…ƒåŒºé—´ [x,x][x, x][x,x] å¯¹äºæ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹ [l,r][l, r][l,r]ï¼Œä»–çš„å·¦å­èŠ‚ç‚¹æ˜¯ [mid+1,r][mid+1, r][mid+1,r], å…¶ä¸­ mid = (l+r) &gt;&gt; 1 å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ˜¯ä¸€é¢—äºŒå‰æ ‘è§†è§’çš„çº¿æ®µæ ‘ï¼Œæˆ‘ä»¬è¦åšçš„å°±æ˜¯åšå¥½æ¯ä¸ªèŠ‚ç‚¹çš„ç»Ÿè®¡ä¿¡æ¯ã€‚ çº¿æ®µæ ‘æŸ¥è¯¢ã€æ›´æ–°çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(logN)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯O(4N)ï¼ˆè‡³äºä¸ºä»€ä¹ˆï¼Œå¯ä»¥å‚ç…§ä¸Šå›¾è¯æ˜ä¸‹å°±å¯ä»¥äº†ï¼‰ï¼Œæ”¯æŒåŒºé—´æ“ä½œçš„ï¼ˆåŒºé—´æ“ä½œçš„æ—¶å€™è¦åšæ‡’æ ‡è®°ï¼Œå³ pushdown æ“ä½œï¼‰ã€‚ ä¸‹é¢æ˜¯å®ç°æ–¹å¼ const int N = 2e5 + 10; // å»ºç«‹ç»“æ„ä½“ï¼Œç©ºé—´æ˜¯åŸå§‹æ•°ç»„çš„4å€ struct Node { int l, r; int val; } tr[N &lt;&lt; 2]; // ç”±å­èŠ‚ç‚¹ï¼Œå‘ä¸Šè®°å½•ç»Ÿè®¡ä¿¡æ¯ï¼Œå¦‚æœ¬å¤„è®°å½•çš„æ˜¯å·¦å³èŠ‚ç‚¹å“ªä¸ªæœ€å¤§ void pushUp(int u) { tr[u].val = max(tr[u &lt;&lt; 1].val, tr[u &lt;&lt; 1 | 1].val); } // l, rä½œä¸ºæ–°å»ºèŠ‚ç‚¹çš„åŒºé—´ä¿¡æ¯ï¼Œu ä»£è¡¨èŠ‚ç‚¹ä¸‹æ ‡ void build(int l, int r, int u) { tr[u].l = l, tr[u].r = r; if (l == r) return; int mid = l + r &gt;&gt; 1; build(l, mid, u &lt;&lt; 1); build(mid + 1, r, u &lt;&lt; 1 | 1); } // å•ç‚¹ä¿®æ”¹ä¸‹æ ‡ i ä½ç½®çš„å€¼ void modify(int u, int i, int v) { int l = tr[u].l, r = tr[u].r; if (l == r) { tr[u].val = v; return; } // æŸ¥æ‰¾åº”è¯¥æ›´æ–°å“ªä¸€è¾¹ int mid = l + r &gt;&gt; 1; if (i &lt;= mid) modify(u &lt;&lt; 1, i, v); else modify(u &lt;&lt; 1 | 1, i, v); // é€’å½’å®Œä¹‹åï¼Œæ›´æ–°æœ¬èŠ‚ç‚¹çš„å€¼ pushUp(u); } // æŸ¥è¯¢åŒºé—´l, rä¹‹é—´çš„æœ€å¤§æ•°æ˜¯å¤šå°‘ int query(int l, int r, int u) { // å¦‚æœåˆšå¥½å¯¹åº”ï¼Œåˆ™è¿”å› if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].val; int mid = tr[u].l + tr[u].r &gt;&gt; 1; // å¦‚æœæ•´ä¸ªåœ¨å·¦è¾¹ if (r &lt;= mid) return query(l, r, u &lt;&lt; 1); // å¦‚æœæ•´ä¸ªåœ¨å³è¾¹ else if (l &gt; mid) return query(l, r, u &lt;&lt; 1 | 1); // è·¨è¶Šä¸¤è¾¹ else return max(query(l, mid, u &lt;&lt; 1), query(mid + 1, r, u &lt;&lt; 1 | 1)); } 2. ä¸€äº›åŸºæœ¬ä½¿ç”¨ ã€ä¾‹é¢˜1ã€‘æœ€å¤§æ•° ç»™å®šä¸€ä¸ªæ­£æ•´æ•°æ•°åˆ— a1,a2,â€¦,ana_1,a_2,â€¦,a_na1â€‹,a2â€‹,â€¦,anâ€‹ æ¯ä¸€ä¸ªæ•°éƒ½åœ¨ 0âˆ¼pâˆ’1 ä¹‹é—´ã€‚ å¯ä»¥å¯¹è¿™åˆ—æ•°è¿›è¡Œä¸¤ç§æ“ä½œï¼š æ·»åŠ æ“ä½œï¼šå‘åºåˆ—åæ·»åŠ ä¸€ä¸ªæ•°ï¼Œåºåˆ—é•¿åº¦å˜æˆ n+1ï¼› è¯¢é—®æ“ä½œï¼šè¯¢é—®è¿™ä¸ªåºåˆ—ä¸­æœ€å L ä¸ªæ•°ä¸­æœ€å¤§çš„æ•°æ˜¯å¤šå°‘ã€‚ ç¨‹åºè¿è¡Œçš„æœ€å¼€å§‹ï¼Œæ•´æ•°åºåˆ—ä¸ºç©ºã€‚ ä¸€å…±è¦å¯¹æ•´æ•°åºåˆ—è¿›è¡Œ m æ¬¡æ“ä½œã€‚ å†™ä¸€ä¸ªç¨‹åºï¼Œè¯»å…¥æ“ä½œçš„åºåˆ—ï¼Œå¹¶è¾“å‡ºè¯¢é—®æ“ä½œçš„ç­”æ¡ˆã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ­£æ•´æ•° m,pï¼Œæ„ä¹‰å¦‚é¢˜ç›®æè¿°ï¼› æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯ä¸€è¡Œè¡¨ç¤ºä¸€ä¸ªæ“ä½œã€‚ å¦‚æœè¯¥è¡Œçš„å†…å®¹æ˜¯ Q Lï¼Œåˆ™è¡¨ç¤ºè¿™ä¸ªæ“ä½œæ˜¯è¯¢é—®åºåˆ—ä¸­æœ€å LL ä¸ªæ•°çš„æœ€å¤§æ•°æ˜¯å¤šå°‘ï¼› å¦‚æœæ˜¯ A tï¼Œåˆ™è¡¨ç¤ºå‘åºåˆ—åé¢åŠ ä¸€ä¸ªæ•°ï¼ŒåŠ å…¥çš„æ•°æ˜¯ (t+a) mod pã€‚å…¶ä¸­ï¼Œt æ˜¯è¾“å…¥çš„å‚æ•°ï¼Œa æ˜¯åœ¨è¿™ä¸ªæ·»åŠ æ“ä½œä¹‹å‰æœ€åä¸€ä¸ªè¯¢é—®æ“ä½œçš„ç­”æ¡ˆï¼ˆå¦‚æœä¹‹å‰æ²¡æœ‰è¯¢é—®æ“ä½œï¼Œåˆ™ a=0ï¼‰ã€‚ ç¬¬ä¸€ä¸ªæ“ä½œä¸€å®šæ˜¯æ·»åŠ æ“ä½œã€‚å¯¹äºè¯¢é—®æ“ä½œï¼ŒL&gt;0 ä¸”ä¸è¶…è¿‡å½“å‰åºåˆ—çš„é•¿åº¦ã€‚ è¾“å‡ºæ ¼å¼ å¯¹äºæ¯ä¸€ä¸ªè¯¢é—®æ“ä½œï¼Œè¾“å‡ºä¸€è¡Œã€‚è¯¥è¡Œåªæœ‰ä¸€ä¸ªæ•°ï¼Œå³åºåˆ—ä¸­æœ€å LL ä¸ªæ•°çš„æœ€å¤§æ•°ã€‚ æ•°æ®èŒƒå›´ 1â‰¤mâ‰¤2Ã—1051â‰¤mâ‰¤2Ã—10^51â‰¤mâ‰¤2Ã—105 1â‰¤pâ‰¤2Ã—1091â‰¤pâ‰¤2Ã—10^91â‰¤pâ‰¤2Ã—109 0â‰¤t&lt;p0â‰¤t&lt;p0â‰¤t&lt;p è¾“å…¥æ ·ä¾‹ï¼š 10 100 A 97 Q 1 Q 1 A 17 Q 2 A 63 Q 1 Q 1 Q 3 A 99 è¾“å‡ºæ ·ä¾‹ï¼š 97 97 97 60 60 97 æ ·ä¾‹è§£é‡Š æœ€åçš„åºåˆ—æ˜¯ 97,14,60,96 å®ç°ä»£ç å¦‚ä¸‹ #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 2e5 + 10; struct Node { int l, r; int val; } tr[N &lt;&lt; 2]; void pushUp(int u) { tr[u].val = max(tr[u &lt;&lt; 1].val, tr[u &lt;&lt; 1 | 1].val); } void build(int l, int r, int u) { tr[u].l = l, tr[u].r = r; if (l == r) return; int mid = l + r &gt;&gt; 1; build(l, mid, u &lt;&lt; 1); build(mid + 1, r, u &lt;&lt; 1 | 1); } void modify(int u, int i, int v) { int l = tr[u].l, r = tr[u].r; if (l == r) { tr[u].val = v; return; } int mid = l + r &gt;&gt; 1; if (i &lt;= mid) modify(u &lt;&lt; 1, i, v); else modify(u &lt;&lt; 1 | 1, i, v); pushUp(u); } int query(int l, int r, int u) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].val; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (r &lt;= mid) return query(l, r, u &lt;&lt; 1); else if (l &gt; mid) return query(l, r, u &lt;&lt; 1 | 1); else return max(query(l, mid, u &lt;&lt; 1), query(mid + 1, r, u &lt;&lt; 1 | 1)); } int main() { int m, p, k, n = 0; int last = 0; build(1, N, 1); cin &gt;&gt; m &gt;&gt; p; while (m--) { char op[2]; scanf(&quot;%s%d&quot;, op, &amp;k); if (op[0] == 'Q') { last = query(n - k + 1, n, 1); cout &lt;&lt; last &lt;&lt; endl; } else { modify(1, ++n, (k + last) % p); } } return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-xian-duan-shu/"},{"title":"ã€æ•°æ®ç»“æ„ã€‘æ ‘çŠ¶æ•°ç»„","content":"1. æ ‘çŠ¶æ•°ç»„åŸºæœ¬ä»‹ç»ä¸å®ç° æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ä¸ªåŠ¨æ€ç»´æŠ¤å‰ç¼€å’Œçš„æ•°æ®ç»“æ„ï¼Œå…¶åˆ©ç”¨çš„æ˜¯äºŒè¿›åˆ¶ä½è½¬åŒ–çš„å…³ç³»ï¼Œä¿è¯æŸ¥è¯¢å’Œæ’å…¥çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O (logN)ï¼Œ ç©ºé—´å¤æ‚åº¦ä¸º O(N)ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œç²‰è‰²ä»£è¡¨å¼€è¾Ÿå‡ºçš„ç©ºé—´æ•°ç»„ï¼Œä»£è¡¨æŒ‡å‘çš„æ‰€æœ‰å—çš„å’Œã€‚ å¦‚æœè¦ç®—å‡ºå‰7ï¼ˆ111Bï¼‰çš„å’Œï¼Œå¦‚å›¾å¯çŸ¥ï¼Œåªéœ€ç®—å‡º 4(100B)ã€6(110B)ã€7(111B) 3å¤„çš„å’Œå³å¯ï¼Œæ ¹æ® 7ï¼ˆ111Bï¼‰ï¼Œ åˆ å»å…¶2è¿›åˆ¶çš„æœ«å°¾1å³å¾—åˆ° 6ï¼ˆ110Bï¼‰, æ ¹æ® 6ï¼ˆ110Bï¼‰ï¼Œ åˆ å»å…¶2è¿›åˆ¶çš„æœ«å°¾1å³å¾—åˆ° 4ï¼ˆ100Bï¼‰,ä½¿å¾—å…¶å…·æœ‰å¤©ç„¶çš„å…³ç³»æ€§ã€‚ï¼ˆ111 -&gt; 110 -&gt; 100ï¼‰ lowbitæ•°ç»„ï¼šå¯¹äºæ•° x ï¼Œ å¯å¾—åˆ°å…¶æœ«å°¾ 1 çš„å€¼ int lowbit(int x) { return x &amp; (-x); } è¯æ˜å¦‚ä¸‹å›¾ ä¸‹é¢æ˜¯å®ç°æ–¹å¼ï¼ˆå¾€å¾€ä¸ç¦»æ•£åŒ–ä¸€èµ·ä½¿ç”¨ï¼‰ int bit[N]; int lowbit(int x) { return x &amp; (-x); } int query(int x) { int ans = 0; while (x &gt; 0) { ans += bit[x]; x -= lowbit(x); } return ans; } void add(int x, int val) { while (x &lt; N) { bit[x] += val; x += lowbit(x); } } 2. ä¸€äº›åŸºæœ¬ä½¿ç”¨ ã€ä¾‹é¢˜ã€‘é€†åºå¯¹ åœ¨æ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºåé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ã€‚è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œæ±‚å‡ºè¿™ä¸ªæ•°ç»„ä¸­çš„é€†åºå¯¹çš„æ€»æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [7,5,6,4] è¾“å‡º: 5 å®ç°ä»£ç å¦‚ä¸‹ #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; const int SIZE = 5e5 + 10; class Solution { int bit[SIZE]; int lowbit(int x) { return x &amp; (-x); } int query(int x) { int ans = 0; while (x &gt; 0) { ans += bit[x]; x -= lowbit(x); } return ans; } void add(int x, int val) { while (x &lt; SIZE) { bit[x] += val; x += lowbit(x); } } unordered_map&lt;int, int&gt; real2idx; public: int reversePairs(vector&lt;int&gt; &amp;nums) { vector&lt;int&gt; copyNum(nums); // ç¦»æ•£åŒ– sort(copyNum.begin(), copyNum.end()); int cnt = 1; for (int num : copyNum) { if (real2idx.count(num)) continue; real2idx[num] = cnt++; } int ans = 0; for (int num : nums) { ans += query(SIZE - 1) - query(real2idx[num]); add(real2idx[num], 1); } return ans; } }; ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-shu-zhuang-shu-zu/"},{"title":"ã€ZooKeeperã€‘ ï¼ˆä¸€ï¼‰äº†è§£ZooKeeper ","content":" ZooKeeper æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼åè°ƒæœåŠ¡çš„å¼€æºæ¡†æ¶ã€‚ä¸»è¦ç”¨æ¥è§£å†³åˆ†å¸ƒå¼é›†ç¾¤ä¸­åº”ç”¨ç³»ç»Ÿçš„ä¸€è‡´æ€§çš„é—®é¢˜ã€‚å…¶æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼çš„å°æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿã€‚æä¾›åŸºäºç±»ä¼¼äºæ–‡ä»¶ç³»ç»Ÿçš„ç›®å½•æ ‘æ–¹å¼çš„æ•°æ®å­˜å‚¨ï¼Œå¹¶ä¸”å¯ä»¥å¯¹æ ‘ä¸­ çš„èŠ‚ç‚¹è¿›è¡Œæœ‰æ•ˆç®¡ç†ã€‚ä»è€Œæ¥ç»´æŠ¤å’Œç›‘æ§ä½ å­˜å‚¨çš„æ•°æ®çš„çŠ¶æ€å˜åŒ–ã€‚å°†é€šè¿‡ç›‘æ§è¿™äº›æ•°æ®çŠ¶æ€çš„å˜åŒ–ï¼Œä»è€Œå¯ä»¥è¾¾åˆ°åŸºäºæ•°æ®çš„é›†ç¾¤ç®¡ç†ã€‚ Paxosç®—æ³•ï¼š è™šæ‹ŸåŒæ­¥æŠ€æœ¯(virtual synchrony)ï¼š 1.1 Zookeeper åŸºç¡€ znode : ç±»ä¼¼äºæ–‡ä»¶ç³»ç»Ÿçš„å±‚çº§æ ‘çŠ¶ç»“æ„ â€‹ åœ¨è¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿé‡Œé¢ï¼Œæ˜¯ä¸€ä¸ªä¸»-ä»ç»“æ„çš„ç¤ºä¾‹ ZooKeeper APIæš´éœ²çš„æ–¹æ³•ï¼š create/path data : åˆ›å»ºä¸€ä¸ªåä¸º /path çš„ znode èŠ‚ç‚¹ï¼Œå¹¶åŒ…å«æ•°æ® data delete/path : åˆ é™¤ /path çš„ znode exist/path : æ£€æŸ¥æ˜¯å¦å­˜åœ¨åä¸º /path çš„èŠ‚ç‚¹ setData/path data : è®¾ç½®åä¸º /path çš„ znode çš„æ•°æ®ä¸º data getData/path : è¿”å›åä¸º /path èŠ‚ç‚¹çš„æ•°æ®ä¿¡æ¯ getChildren/path : è¿”å›æ‰€æœ‰ /path èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹åˆ—è¡¨ ZooKeeper ä¸å…è®¸å±€éƒ¨å†™å…¥æˆ–è¯»å–znodeèŠ‚ç‚¹çš„æ•°æ® znode çš„ä¸åŒç±»å‹ å½“æ–°å»ºznodeæ—¶ï¼Œè¿˜éœ€è¦æŒ‡å®šè¯¥èŠ‚ç‚¹çš„ç±»å‹(mode)ï¼Œä¸åŒçš„ç±»å‹ å†³å®šäº†znodeèŠ‚ç‚¹çš„è¡Œä¸ºæ–¹å¼ã€‚ æŒä¹…èŠ‚ç‚¹å’Œä¸´æ—¶èŠ‚ç‚¹ ï¼š æŒä¹…çš„znodeï¼Œå¦‚/pathï¼Œåªèƒ½é€šè¿‡è°ƒç”¨deleteæ¥è¿›è¡Œ åˆ é™¤ã€‚ä¸´æ—¶çš„znodeä¸ä¹‹ç›¸åï¼Œå½“åˆ›å»ºè¯¥èŠ‚ç‚¹çš„å®¢æˆ·ç«¯å´©æºƒæˆ–å…³é—­äº†ä¸ ZooKeeperçš„è¿æ¥æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹å°±ä¼šè¢«åˆ é™¤ã€‚ ä¸€ä¸ªä¸´æ—¶znodeï¼Œåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸‹å°†ä¼šè¢«åˆ é™¤: 1.å½“åˆ›å»ºè¯¥znodeçš„å®¢æˆ·ç«¯çš„ä¼šè¯å› è¶…æ—¶æˆ–ä¸»åŠ¨å…³é—­è€Œä¸­æ­¢æ—¶ã€‚ 2.å½“æŸä¸ªå®¢æˆ·ç«¯(ä¸ä¸€å®šæ˜¯åˆ›å»ºè€…)ä¸»åŠ¨åˆ é™¤è¯¥èŠ‚ç‚¹æ—¶ã€‚ æœ‰åºèŠ‚ç‚¹ ï¼š ä¸€ä¸ªæœ‰åºznodeèŠ‚ ç‚¹è¢«åˆ†é…å”¯ä¸€ä¸ªå•è°ƒé€’å¢çš„æ•´æ•°ã€‚å½“åˆ›å»ºæœ‰åºèŠ‚ç‚¹æ—¶ï¼Œä¸€ä¸ªåºå·ä¼šè¢«è¿½åŠ åˆ°è·¯å¾„ä¹‹åã€‚æœ‰åºznodeé€šè¿‡ æä¾›äº†åˆ›å»ºå…·æœ‰å”¯ä¸€åç§°çš„znodeçš„ç®€å•æ–¹å¼ã€‚åŒæ—¶ä¹Ÿé€šè¿‡è¿™ç§æ–¹å¼å¯ä»¥ç›´è§‚åœ°æŸ¥çœ‹znodeçš„åˆ›å»ºé¡ºåºã€‚ ç»¼ä¸Šï¼Œznodeä¸€å…±æœ‰4ç§ç±»å‹:æŒä¹…çš„(persistent)ã€ä¸´æ—¶çš„ (ephemeral)ã€æŒä¹…æœ‰åºçš„(persistent_sequential)å’Œä¸´æ—¶æœ‰åºçš„ (ephemeral_sequential)ã€‚ ç›‘è§†ä¸é€šçŸ¥ ZooKeeperé€šå¸¸ä»¥è¿œç¨‹æœåŠ¡çš„æ–¹å¼è¢«è®¿é—®ï¼Œå¦‚æœæ¯æ¬¡è®¿é—®znodeæ—¶ï¼Œ å®¢æˆ·ç«¯éƒ½éœ€è¦è·å¾—èŠ‚ç‚¹ä¸­çš„å†…å®¹ï¼Œè¿™æ ·çš„ä»£ä»·å°±éå¸¸å¤§ã€‚å› ä¸ºè¿™æ ·ä¼šå¯¼è‡´æ›´é«˜çš„å»¶è¿Ÿï¼Œè€Œä¸”ZooKeeperéœ€è¦åšæ›´å¤šçš„æ“ä½œã€‚ ä¸ºæ­¤ï¼ŒåŸºäºé€šçŸ¥çš„æœºåˆ¶ ï¼š å®¢æˆ·ç«¯å‘ZooKeeperæ³¨å†Œéœ€è¦æ¥æ”¶é€šçŸ¥çš„ znodeï¼Œé€šè¿‡å¯¹znodeè®¾ç½®ç›‘è§†ç‚¹(watch)æ¥æ¥æ”¶é€šçŸ¥ã€‚ ç‰ˆæœ¬ æ¯ä¸€ä¸ªznodeéƒ½æœ‰ä¸€ä¸ªç‰ˆæœ¬å·ï¼Œå®ƒéšç€æ¯æ¬¡æ•°æ®å˜åŒ–è€Œè‡ªå¢ã€‚ä½¿ç”¨ç‰ˆæœ¬æ¥é˜»æ­¢å¹¶è¡Œæ“ä½œçš„ä¸ä¸€è‡´æ€§ã€‚ 1.2 Zookeeper æ¶æ„ ZooKeeperæœåŠ¡å™¨ç«¯è¿è¡Œäºä¸¤ç§æ¨¡å¼ä¸‹:ç‹¬ç«‹æ¨¡å¼(standalone)å’Œ ä»²è£æ¨¡å¼(quorum)ã€‚ç‹¬ç«‹æ¨¡å¼å‡ ä¹ä¸å…¶æœ¯è¯­æ‰€æè¿°çš„ä¸€æ ·:æœ‰ä¸€ä¸ªå•ç‹¬çš„æœåŠ¡å™¨ï¼ŒZooKeeperçŠ¶æ€æ— æ³•å¤åˆ¶ã€‚åœ¨ä»²è£æ¨¡å¼ä¸‹ï¼Œå…·æœ‰ä¸€ç»„ ZooKeeperæœåŠ¡å™¨ï¼Œæˆ‘ä»¬ç§°ä¸ºZooKeeperé›†åˆ(ZooKeeper ensemble)ï¼Œå®ƒä»¬ä¹‹å‰å¯ä»¥è¿›è¡ŒçŠ¶æ€çš„å¤åˆ¶ï¼Œå¹¶åŒæ—¶ä¸ºæœåŠ¡äºå®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚ è¿™é‡Œé‡ç‚¹ä»‹ç»ä¸‹ ä»²è£æ¨¡å¼ ï¼š åœ¨ä»²è£æ¨¡å¼ä¸‹ï¼ŒZooKeeperå¤åˆ¶é›†ç¾¤ä¸­çš„æ‰€æœ‰æœåŠ¡å™¨çš„æ•°æ®æ ‘ã€‚ä½†å¦‚æœè®©ä¸€ä¸ªå®¢æˆ·ç«¯ç­‰å¾…æ¯ä¸ªæœåŠ¡å™¨å®Œæˆæ•°æ®ä¿å­˜åå†ç»§ç»­ï¼Œå»¶è¿Ÿé—®é¢˜å°†æ— æ³•æ¥å—ã€‚ä¾‹å¦‚æœ‰5å°æœºå™¨ï¼Œå¿…é¡»æœ‰3å°è¿›è¡Œæ“ä½œç¡®è®¤ï¼›4å°æœºå™¨ï¼Œå¿…é¡»æœ‰3å°è¿›è¡Œæ“ä½œç¡®è®¤ï¼›å¯ä»¥çœ‹å‡ºï¼Œå¥‡æ•°å°çš„æ€§ä»·æ¯”é«˜äº›ã€‚ ä¼šè¯ åœ¨å¯¹ZooKeeperé›†åˆæ‰§è¡Œä»»ä½•è¯·æ±‚å‰ï¼Œä¸€ä¸ªå®¢æˆ·ç«¯å¿…é¡»å…ˆä¸æœåŠ¡å»ºç«‹ä¼šè¯ã€‚ä¼šè¯çš„æ¦‚å¿µéå¸¸é‡è¦ï¼Œå¯¹ZooKeeperçš„è¿è¡Œä¹Ÿéå¸¸å…³é”®ã€‚å®¢æˆ·ç«¯æäº¤ç»™ZooKeeperçš„æ‰€æœ‰æ“ä½œå‡å…³è”åœ¨ä¸€ä¸ªä¼šè¯ä¸Šã€‚å½“ä¸€ä¸ªä¼šè¯å› æŸç§åŸå› è€Œä¸­æ­¢æ—¶ï¼Œåœ¨è¿™ä¸ªä¼šè¯æœŸé—´åˆ›å»ºçš„ä¸´æ—¶èŠ‚ç‚¹å°†ä¼šæ¶ˆå¤±ã€‚ å®¢æˆ·ç«¯é€šè¿‡TCPåè®®ä¸æœåŠ¡å™¨è¿›è¡Œè¿æ¥å¹¶é€šä¿¡ï¼Œ ä½†å½“ä¼šè¯æ— æ³•ä¸å½“å‰è¿æ¥çš„æœåŠ¡å™¨ç»§ç»­é€šä¿¡æ—¶ï¼Œä¼šè¯å°±å¯èƒ½è½¬ç§»åˆ°å¦ä¸€ä¸ªæœåŠ¡å™¨ä¸Šã€‚ä¼šè¯æä¾›äº†é¡ºåºä¿éšœï¼Œè¿™å°±æ„å‘³ç€åŒä¸€ä¸ªä¼šè¯ä¸­çš„è¯·æ±‚ä¼šä»¥FIFO(å…ˆè¿›å…ˆå‡º)é¡ºåºæ‰§è¡Œ 2.3 å¼€å§‹ä½¿ç”¨ZooKeeperï¼ˆMAC OSï¼‰ é¦–å…ˆä»å®˜ç½‘ä¸‹è½½zookeeperå‹ç¼©åŒ… https://zookeeper.apache.org/releases.html æ‰¾åˆ°éœ€è¦ä¸‹è½½çš„åŒ… Apache ZooKeeper 3.7.0 Source Release(asc, sha512) å¾—åˆ°å‹ç¼©åŒ… apache-zookeeper-3.7.0-bin.tar.gz è¿›å…¥ç›¸åº”æ–‡ä»¶å¤¹ï¼Œè§£å‹å‹ç¼©åŒ… tar -zxvf ./apache-zookeeper-3.7.0-bin.tar.gz è¿›å…¥è§£å‹åçš„æ–‡ä»¶ç›®å½•ï¼Œä¿®æ”¹é…ç½®æ–‡ä»¶ï¼Œä½äºconfæ–‡ä»¶å¤¹ä¸‹, é‡å‘½åä¸º zoo.cfg ä¿®æ”¹ zoo.cfg, å¯ä»¥ä¿®æ”¹ DataDir æ–‡ä»¶å¤¹ä½ç½®ï¼Œç”¨æ¥zookeeperå»ºç›®å½•ç”¨çš„ å¯åŠ¨ ./bin/zkServer.sh start ä¸Šé¢è¿™ä¸ªå‘½ä»¤æ˜¯åå°è¿è¡Œ å¦‚æœæƒ³åœ¨å‰å°è¿è¡Œå¹¶è¾“å‡ºå‘½ä»¤ï¼Œå¯ä»¥ç”¨ ./bin/zkServer.sh start-foreground æš‚åœ ./bin/zkServer.sh stop ä¼šè¯å»ºç«‹ ./bin/zkCli.sh å»ºç«‹èŠ‚ç‚¹ï¼Œåˆ é™¤å¹¶é€€å‡ºä¼šè¯ ","link":"https://tofindmore.github.io/post/zookeeper-zhi-liao-jie-zookeeper/"},{"title":"ã€æ•°æ®ç»“æ„ã€‘å•è°ƒæ ˆ ","content":" 1. ä½•è°“å•è°ƒæ ˆ å•è°ƒæ ˆå³æ»¡è¶³å•è°ƒæ€§çš„æ ˆç»“æ„ã€‚åœ¨é‡åˆ°å®é™…æƒ…å†µæ—¶ï¼Œéœ€è¦å°†ä¸éœ€è¦ç»´æŠ¤çš„æ•°æ®ä»æ ˆé¡¶å¼¹å‡ºï¼Œç»´æŠ¤é˜Ÿåˆ—å•è°ƒæ€§ã€‚ ä¸€èˆ¬çš„å¤„ç†ä»£ç å¦‚ä¸‹ // å•è°ƒé€’å¢æ ˆï¼Œæ’å…¥ t while(!stk.empty() &amp;&amp; stk.top() &gt;= t) stk.pop(); stk.push(t); 2. å®é™…ä¸­çš„é—®é¢˜ P1 å•è°ƒæ ˆ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º N çš„æ•´æ•°æ•°åˆ—ï¼Œè¾“å‡ºæ¯ä¸ªæ•°å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„æ•°ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¾“å‡º âˆ’1ã€‚ // æ ¹æ®é¢˜æ„ï¼Œå¯¹äºæŸä¸ªå¾…æ’å…¥çš„æ•° t æ¥è¯´ï¼Œä¹‹å‰æ‰€æœ‰æ¯” t å¤§çš„æ•°ï¼Œ å¯¹äº t åŠä»¥åçš„æ•°æ¥è¯´éƒ½æ˜¯æ— ç”¨çš„ // 1. Why å¯¹ t æ— ç”¨? ç­”ï¼š t è¦æ‰¾æ¯” t å°çš„ // 2. Why å¯¹ t ä»¥åçš„æ•°ï¼Ÿç­”ï¼šå¦‚æœå¾€å‰æ‰¾ï¼Œæ‰¾tå°±å¥½äº†ï¼Œæ¯” t å‰é¢ä¸”æ¯” t å¤§çš„æ•°ä¸éœ€è¦å†æ¯”è¾ƒäº† #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { int n, t; cin &gt;&gt; n; stack&lt;int&gt; stk; for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;t); while (!stk.empty() &amp;&amp; stk.top() &gt;= t) stk.pop(); if (stk.empty()) cout &lt;&lt; &quot;-1 &quot;; else cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;; stk.push(t); } return 0; } P2 ç›´æ–¹å›¾ä¸­æœ€å¤§çš„çŸ©å½¢ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œç›´æ–¹å›¾æ˜¯ç”±åœ¨å…¬å…±åŸºçº¿å¤„å¯¹é½çš„ä¸€ç³»åˆ—çŸ©å½¢ç»„æˆçš„å¤šè¾¹å½¢ã€‚ çŸ©å½¢å…·æœ‰ç›¸ç­‰çš„å®½åº¦ï¼Œä½†å¯ä»¥å…·æœ‰ä¸åŒçš„é«˜åº¦ã€‚ ä¾‹å¦‚ï¼Œå›¾ä¾‹å·¦ä¾§æ˜¾ç¤ºäº†ç”±é«˜åº¦ä¸º 2,1,4,5,1,3,32,1,4,5,1,3,3 çš„çŸ©å½¢ç»„æˆçš„ç›´æ–¹å›¾ï¼ŒçŸ©å½¢çš„å®½åº¦éƒ½ä¸º 11ï¼š ç°åœ¨ï¼Œè¯·ä½ è®¡ç®—åœ¨å…¬å…±åŸºçº¿å¤„å¯¹é½çš„ç›´æ–¹å›¾ä¸­æœ€å¤§çŸ©å½¢çš„é¢ç§¯ã€‚ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; using namespace std; typedef long long LL; const int N = 1e5 + 10; int l[N], r[N], g[N], n; int main() { while (scanf(&quot;%d&quot;, &amp;n), n) { for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, g + i); g[0] = -1, g[n + 1] = -1; // åˆå§‹åŒ–æ•°ç»„ l[i], è¡¨ç¤ºæ‰€æœ‰ä¸‹æ ‡ i å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„ä¸‹æ ‡ stack&lt;int&gt; stk; stk.push(0); for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); l[i] = stk.top(); stk.push(i); } while (!stk.empty()) stk.pop(); stk.push(n + 1); // åˆå§‹åŒ–æ•°ç»„ r[i], è¡¨ç¤ºæ‰€æœ‰ä¸‹æ ‡ i å³è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„ä¸‹æ ‡ for (int i = n; i &gt;= 1; i--) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); r[i] = stk.top(); stk.push(i); } // æšä¸¾æ‰€æœ‰ä»¥ i ä¸ºé¡¶è¾¹çš„æƒ…å†µ LL ans = 0; for (int i = 1; i &lt;= n; i++) { ans = max(ans, (LL) g[i] * (r[i] - l[i] - 1)); } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } P3 åŸå¸‚æ¸¸æˆ æ±‚è¢« F è¦†ç›–çš„æœ€å¤§çŸ©å½¢é¢ç§¯ï¼Œ æœ¬é¢˜å°±æ˜¯ä¸Šä¸€é¢˜ç›´æ¥çš„å˜å½¢ï¼Œæšä¸¾æ¯ä¸€è¡Œï¼Œå°±å¯ä»¥çœ‹åšæ˜¯ä¸€ä¸ªç›´æ–¹å›¾ R F F F F F F F F F F F R R R F F F F F F F F F F F F F F F #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; using namespace std; typedef long long LL; const int N = 1010; // mp[i][j] è¡¨ç¤ºç¬¬iè¡Œç¬¬jåˆ—æ–¹æ ¼ä¸Šæ–¹åŒ…æ‹¬è‡ªå·±æœ‰å¤šå°‘ä¸ªF, ç›¸å½“äºä¸Šé¢˜ä¸­çš„çŸ©å½¢é«˜åº¦ï¼ï¼ï¼ int l[N], r[N], mp[N][N]; int n, m; int solve(int g[]) { g[0] = -1, g[n + 1] = -1; // åˆå§‹åŒ–æ•°ç»„ l[i], è¡¨ç¤ºæ‰€æœ‰ä¸‹æ ‡ i å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„ä¸‹æ ‡ stack&lt;int&gt; stk; stk.push(0); for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); l[i] = stk.top(); stk.push(i); } while (!stk.empty()) stk.pop(); stk.push(n + 1); // åˆå§‹åŒ–æ•°ç»„ r[i], è¡¨ç¤ºæ‰€æœ‰ä¸‹æ ‡ i å³è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„ä¸‹æ ‡ for (int i = n; i &gt;= 1; i--) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); r[i] = stk.top(); stk.push(i); } // æšä¸¾æ‰€æœ‰ä»¥ i ä¸ºé¡¶è¾¹çš„æƒ…å†µ LL ans = 0; for (int i = 1; i &lt;= n; i++) { ans = max(ans, (LL) g[i] * (r[i] - l[i] - 1)); } return ans; } int main() { cin &gt;&gt; m &gt;&gt; n; char c[3]; int ans = 0; for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { scanf(&quot;%s&quot;, &amp;c); if(c[0] == 'F') mp[i][j] = mp[i-1][j] + 1; } ans = max(ans, solve(mp[i])); } cout &lt;&lt; ans * 3 &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-dan-diao-zhan/"},{"title":"ã€æ•°æ®ç»“æ„ã€‘Trieæ ‘","content":"1. Trie æ ‘åŸºæœ¬ä»‹ç»ä¸å®ç° Trie(å­—å…¸æ ‘)æ˜¯ä¸€ç§ç”¨äºå®ç°å­—ç¬¦ä¸²ï¼ˆä¸ä¸€å®šæ˜¯å­—ç¬¦ä¸²ï¼Œå¦‚ä¸€ä¸ªæ•´æ•°çš„äºŒè¿›åˆ¶ä¸²ç­‰ï¼‰å¿«é€Ÿæ£€ç´¢çš„å¤šå‰æ ‘ç»“æ„ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ˜¯å­—ç¬¦ä¸² &quot;cab&quot;ã€&quot;cos&quot;ã€&quot;car&quot;ã€&quot;cat&quot;ã€&quot;cate&quot;ã€&quot;rain&quot; æ’å…¥æ“ä½œã€‚ ä¸‹é¢æ˜¯å»ºæ ‘ã€æŸ¥æ‰¾çš„ä»£ç å®ç° // tr[i][j] è¡¨ç¤ºä¸‹æ ‡ i èŠ‚ç‚¹ä¸‹ j å·å­èŠ‚ç‚¹çš„ä¸‹æ ‡ï¼Œ æ­¤å¤„26æ˜¯ä»…æœ‰å°å†™å­—æ¯çš„åˆé›† // idx æ˜¯è‡ªå¢çš„ä¸‹æ ‡ int tr[M][26], idx; // æ’å…¥æŸä¸ªå­—ç¬¦ä¸² void insert(char *str) { // åˆå§‹åŒ–ä¸ºæ ¹èŠ‚ç‚¹ï¼Œè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // å¦‚æœå­èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°èŠ‚ç‚¹ if (!tr[p][u]) tr[p][u] = ++idx; // æ›´æ–°å¾€ä¸‹è¿­ä»£ p = tr[p][u]; } } // æŸ¥è¯¢æŸä¸ªå­—ç¬¦ä¸²çš„ä¿¡æ¯ï¼Œè¿™é‡Œå¯ä»¥ç»Ÿè®¡å•è¯ä¸ªæ•°ã€å‰ç¼€ä¸ªæ•°ç­‰ int query(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // ... p = tr[p][u]; } // æ ¹æ®é¢˜ç›®è¿”å›ä¸€äº›ä¿¡æ¯ return sth; } 2. Trie çš„ä¸€äº›åŸºæœ¬ä½¿ç”¨ 2.1 ã€ä¾‹é¢˜ã€‘å­—ç¬¦ä¸²ç»Ÿè®¡ ç»´æŠ¤ä¸€ä¸ªå­—ç¬¦ä¸²é›†åˆï¼Œæ”¯æŒä¸¤ç§æ“ä½œï¼š I x å‘é›†åˆä¸­æ’å…¥ä¸€ä¸ªå­—ç¬¦ä¸² xï¼› Q x è¯¢é—®ä¸€ä¸ªå­—ç¬¦ä¸²åœ¨é›†åˆä¸­å‡ºç°äº†å¤šå°‘æ¬¡ã€‚ å…±æœ‰ N ä¸ªæ“ä½œï¼Œè¾“å…¥çš„å­—ç¬¦ä¸²æ€»é•¿åº¦ä¸è¶…è¿‡ 10510^5105ï¼Œå­—ç¬¦ä¸²ä»…åŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«æ•´æ•° Nï¼Œè¡¨ç¤ºæ“ä½œæ•°ã€‚ æ¥ä¸‹æ¥ N è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ“ä½œæŒ‡ä»¤ï¼ŒæŒ‡ä»¤ä¸º I x æˆ– Q x ä¸­çš„ä¸€ç§ã€‚ è¾“å‡ºæ ¼å¼ å¯¹äºæ¯ä¸ªè¯¢é—®æŒ‡ä»¤ Q xï¼Œéƒ½è¦è¾“å‡ºä¸€ä¸ªæ•´æ•°ä½œä¸ºç»“æœï¼Œè¡¨ç¤º x åœ¨é›†åˆä¸­å‡ºç°çš„æ¬¡æ•°ã€‚ æ¯ä¸ªç»“æœå ä¸€è¡Œã€‚ æ•°æ®èŒƒå›´ 1â‰¤Nâ‰¤2âˆ—1041â‰¤Nâ‰¤2âˆ—10^41â‰¤Nâ‰¤2âˆ—104 è¾“å…¥æ ·ä¾‹ï¼š 5 I abc Q abc Q ab I ab Q ab è¾“å‡ºæ ·ä¾‹ï¼š 1 0 1 å®ç°ä»£ç å¦‚ä¸‹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int tr[N][26], idx, cnt[N]; char op[2], str[N]; void insert(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!tr[p][u]) tr[p][u] = ++idx; p = tr[p][u]; } cnt[p]++; } int query(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!tr[p][u]) return 0; p = tr[p][u]; } return cnt[p]; } int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { scanf(&quot;%s%s&quot;, op, str); if (op[0] == 'I') insert(str); else cout &lt;&lt; query(str) &lt;&lt; endl; } return 0; } 2.2 ã€ä¾‹é¢˜ã€‘æœ€å¤§å¼‚æˆ–å¯¹ åœ¨ç»™å®šçš„ N ä¸ªæ•´æ•° $A_1ï¼ŒA_2â€¦â€¦A_N $ä¸­é€‰å‡ºä¸¤ä¸ªè¿›è¡Œ xorï¼ˆå¼‚æˆ–ï¼‰è¿ç®—ï¼Œå¾—åˆ°çš„ç»“æœæœ€å¤§æ˜¯å¤šå°‘ï¼Ÿ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•° Nã€‚ ç¬¬äºŒè¡Œè¾“å…¥ N ä¸ªæ•´æ•° A1ï½ANA_1ï½A_NA1â€‹ï½ANâ€‹ã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚ æ•°æ®èŒƒå›´ 1â‰¤Nâ‰¤1051â‰¤Nâ‰¤10^51â‰¤Nâ‰¤105 0â‰¤Ai&lt;2310â‰¤A_i&lt;2^{31}0â‰¤Aiâ€‹&lt;231 è¾“å…¥æ ·ä¾‹ï¼š 3 1 2 3 è¾“å‡ºæ ·ä¾‹ï¼š 3 å®ç°ä»£ç å¦‚ä¸‹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10, M = 31 * N; int tr[M][2], idx, nums[N]; void insert(int x) { int p = 0; for (int i = 30; i &gt;= 0; i--) { int u = x &gt;&gt; i &amp; 1; if (!tr[p][u]) tr[p][u] = ++idx; p = tr[p][u]; } } int query(int x) { int p = 0, ret = 0; for (int i = 30; i &gt;= 0; i--) { int u = x &gt;&gt; i &amp; 1; if (tr[p][u ^ 1]) p = tr[p][u ^ 1], ret += (1 &lt;&lt; i); else p = tr[p][u]; } return ret; } int main() { int n, x; cin &gt;&gt; n; int tot = -1; while (n--) { cin &gt;&gt; x; insert(x); nums[++tot] = x; } int ans = 0; for (int i = 0; i &lt;= tot; i++) { ans = max(ans, query(nums[i])); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-trie-shu-ji-qi-chi-jiu-hua/"},{"title":"ã€æ•°æ®ç»“æ„ã€‘å¹¶æŸ¥é›†","content":"1. å¹¶æŸ¥é›†åŸºæœ¬ä»‹ç»ä¸å®ç° å¹¶æŸ¥é›†ï¼ˆDisjoint-Setï¼‰æ˜¯ä¸€ç§å¯ä»¥åŠ¨æ€ç»´æŠ¤è‹¥å¹²ä¸ªä¸é‡åˆçš„é›†åˆï¼Œå¹¶æ”¯æŒåˆå¹¶å’ŒæŸ¥è¯¢çš„æ•°æ®ç»“æ„ã€‚å³æœ‰ä¸¤ç§åŸºæœ¬æ“ä½œï¼š Get ï¼šæŸ¥è¯¢ä¸€ä¸ªå…ƒç´ å±äºå“ªä¸€ä¸ªé›†åˆ Merge ï¼šæŠŠä¸¤ä¸ªé›†åˆåˆå¹¶æˆä¸€ä¸ªå¤§é›†åˆ ä¸ºäº†é˜²æ­¢æ’å…¥é€€åŒ–ï¼Œæœ¬åšå®¢ä½¿ç”¨çš„æ–¹æ³•æ˜¯ï¼šè·¯å¾„å‹ç¼©ï¼ˆåœ¨findå‡½æ•°ä¸­åˆ©ç”¨ä¼ å‚èµ‹å€¼çš„æ–¹å¼ï¼‰ ä¸‹é¢æ˜¯å¹¶æŸ¥é›†çš„å®ç°æ–¹å¼ int p[N]; void init() { for(int i=0;i&lt;N;i++) p[i] = i; } // å‹ç¼©åï¼Œæ—¶é—´å¤æ‚åº¦å¯ä»¥è®¤ä¸ºæ˜¯O(1) int find(int x) { // æ­¤å¤„è¿›è¡Œäº†è·¯å¾„å‹ç¼© if (x != p[x]) p[x] = find(p[x]); return p[x]; } void merge(int x, int y) { int p1 = find(x); int p2 = find(y); // å¦‚æœä¸¤è€…ä¸ç­‰ï¼Œ è¯´æ˜ä¸åœ¨åŒä¸€ä¸ªé›†åˆï¼Œå°†ä¸¤è€…è¿›è¡Œåˆå¹¶æ“ä½œ if (p1 != p2) p[p1] = p2; } 2. ä¸€äº›åŸºæœ¬ä½¿ç”¨ ã€ä¾‹é¢˜ã€‘ç¨‹åºè‡ªåŠ¨åˆ†æ åœ¨å®ç°ç¨‹åºè‡ªåŠ¨åˆ†æçš„è¿‡ç¨‹ä¸­ï¼Œå¸¸å¸¸éœ€è¦åˆ¤å®šä¸€äº›çº¦æŸæ¡ä»¶æ˜¯å¦èƒ½è¢«åŒæ—¶æ»¡è¶³ã€‚ è€ƒè™‘ä¸€ä¸ªçº¦æŸæ»¡è¶³é—®é¢˜çš„ç®€åŒ–ç‰ˆæœ¬ï¼šå‡è®¾ x1,x2,x3,â€¦x1,x2,x3,â€¦x1,x2,x3,â€¦ä»£è¡¨ç¨‹åºä¸­å‡ºç°çš„å˜é‡ï¼Œç»™å®š n ä¸ªå½¢å¦‚ xi=xjxi=xj æˆ– xiâ‰ xjx_iâ‰ x_jxiâ€‹î€ â€‹=xjâ€‹ çš„å˜é‡ç›¸ç­‰/ä¸ç­‰çš„çº¦æŸæ¡ä»¶ï¼Œè¯·åˆ¤å®šæ˜¯å¦å¯ä»¥åˆ†åˆ«ä¸ºæ¯ä¸€ä¸ªå˜é‡èµ‹äºˆæ°å½“çš„å€¼ï¼Œä½¿å¾—ä¸Šè¿°æ‰€æœ‰çº¦æŸæ¡ä»¶åŒæ—¶è¢«æ»¡è¶³ã€‚ ä¾‹å¦‚ï¼Œä¸€ä¸ªé—®é¢˜ä¸­çš„çº¦æŸæ¡ä»¶ä¸ºï¼šx1=x2ï¼Œx2=x3ï¼Œx3=x4ï¼Œx1â‰ x4x1=x2ï¼Œx2=x3ï¼Œx3=x4ï¼Œx1â‰ x4x1=x2ï¼Œx2=x3ï¼Œx3=x4ï¼Œx1î€ â€‹=x4ï¼Œè¿™äº›çº¦æŸæ¡ä»¶æ˜¾ç„¶æ˜¯ä¸å¯èƒ½åŒæ—¶è¢«æ»¡è¶³çš„ï¼Œå› æ­¤è¿™ä¸ªé—®é¢˜åº”åˆ¤å®šä¸ºä¸å¯è¢«æ»¡è¶³ã€‚ ç°åœ¨ç»™å‡ºä¸€äº›çº¦æŸæ»¡è¶³é—®é¢˜ï¼Œè¯·åˆ†åˆ«å¯¹å®ƒä»¬è¿›è¡Œåˆ¤å®šã€‚ è¾“å…¥æ ¼å¼ è¾“å…¥æ–‡ä»¶çš„ç¬¬ 1 è¡ŒåŒ…å« 1 ä¸ªæ­£æ•´æ•° tï¼Œè¡¨ç¤ºéœ€è¦åˆ¤å®šçš„é—®é¢˜ä¸ªæ•°ï¼Œæ³¨æ„è¿™äº›é—®é¢˜ä¹‹é—´æ˜¯ç›¸äº’ç‹¬ç«‹çš„ã€‚ å¯¹äºæ¯ä¸ªé—®é¢˜ï¼ŒåŒ…å«è‹¥å¹²è¡Œï¼š ç¬¬ 1 è¡ŒåŒ…å« 1 ä¸ªæ­£æ•´æ•° nï¼Œè¡¨ç¤ºè¯¥é—®é¢˜ä¸­éœ€è¦è¢«æ»¡è¶³çš„çº¦æŸæ¡ä»¶ä¸ªæ•°ã€‚ æ¥ä¸‹æ¥ n è¡Œï¼Œæ¯è¡ŒåŒ…æ‹¬ 3 ä¸ªæ•´æ•° i,j,eï¼Œæè¿° 1ä¸ªç›¸ç­‰/ä¸ç­‰çš„çº¦æŸæ¡ä»¶ï¼Œç›¸é‚»æ•´æ•°ä¹‹é—´ç”¨å•ä¸ªç©ºæ ¼éš”å¼€ã€‚è‹¥ e=1e=1e=1ï¼Œåˆ™è¯¥çº¦æŸæ¡ä»¶ä¸º xi=xjx_i=x_jxiâ€‹=xjâ€‹ï¼›è‹¥ e=0e=0e=0ï¼Œåˆ™è¯¥çº¦æŸæ¡ä»¶ä¸º xiâ‰ xjx_iâ‰ x_jxiâ€‹î€ â€‹=xjâ€‹ã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºæ–‡ä»¶åŒ…æ‹¬ t è¡Œã€‚ è¾“å‡ºæ–‡ä»¶çš„ç¬¬ k è¡Œè¾“å‡ºä¸€ä¸ªå­—ç¬¦ä¸² YES æˆ–è€… NOï¼ŒYES è¡¨ç¤ºè¾“å…¥ä¸­çš„ç¬¬ kk ä¸ªé—®é¢˜åˆ¤å®šä¸ºå¯ä»¥è¢«æ»¡è¶³ï¼ŒNO è¡¨ç¤ºä¸å¯è¢«æ»¡è¶³ã€‚ æ•°æ®èŒƒå›´ $1â‰¤nâ‰¤10^5 $ 1â‰¤i,jâ‰¤1091â‰¤i,jâ‰¤10^91â‰¤i,jâ‰¤109 è¾“å…¥æ ·ä¾‹ï¼š 2 2 1 2 1 1 2 0 2 1 2 1 2 1 1 è¾“å‡ºæ ·ä¾‹ï¼š NO YES å®ç°ä»£ç å¦‚ä¸‹ // æœ¬é¢˜è¦è¿›è¡Œç¦»æ•£åŒ–å¤„ç†ï¼Œæ­¤å¤„çš„ç¦»æ•£æ–¹å¼æ˜¯ï¼šæ’åº -&gt; å»é‡ -&gt; äºŒåˆ†æŸ¥æ‰¾ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int p[2 * N], nums[N * 2], op[N][3], len; int find(int x) { if (x != p[x]) p[x] = find(p[x]); return p[x]; } int getIdx(int x) { return lower_bound(nums, nums + len, x) - nums; } int main() { int T, n; cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; // åˆå§‹åŒ–æ“ä½œ for (int i = 0; i &lt; 2 * N; i++) p[i] = i; int a, b, c; int cnt = -1; for (int i = 0; i &lt; n; i++) { scanf(&quot;%d%d%d&quot;, &amp;op[i][0], &amp;op[i][1], &amp;op[i][2]); nums[++cnt] = op[i][0], nums[++cnt] = op[i][1]; } // ç¦»æ•£åŒ– sort(nums, nums + cnt + 1); len = unique(nums, nums + cnt + 1) - nums; // å¯¹äºç›¸ç­‰çš„æƒ…å†µï¼Œå…ˆå¤„ç†ï¼Œè¿›è¡Œåˆå¹¶ for (int i = 0; i &lt; n; i++) { if (op[i][2]) { int p1 = find(getIdx(op[i][0])); int p2 = find(getIdx(op[i][1])); if (p1 != p2) p[p1] = p2; } } // å¯¹äºä¸ç›¸ç­‰çš„æƒ…å†µï¼Œå¦‚æœå‘ç°å’Œä¹‹å‰çŸ›ç›¾å—ï¼Œåˆ™è¾“å‡ºNO bool flag = false; for (int i = 0; i &lt; n; i++) { if (!op[i][2]) { int p1 = find(getIdx(op[i][0])); int p2 = find(getIdx(op[i][1])); if (p1 == p2) { puts(&quot;NO&quot;), flag = true; break; } } } if (!flag) puts(&quot;YES&quot;); } return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-bing-cha-ji/"},{"title":"ã€å›¾è®ºã€‘å•æºæœ€çŸ­è·¯","content":" å›¾çš„å­˜å‚¨ å¯¹äºæœ‰å‘å›¾è€Œè¨€ï¼Œæœ‰ä¸¤ç§æ–¹å¼çš„å›¾å­˜å‚¨æ–¹å¼ é‚»æ¥è¡¨ å¯¹äºé‚»æ¥è¡¨è€Œè¨€ï¼Œæ¨èé‡‡ç”¨é“¾å¼å‰å‘æ˜Ÿæ•°ç»„çš„å½¢å¼ï¼Œ å¢åŠ èŠ‚ç‚¹å’Œä¾¿åˆ©èŠ‚ç‚¹çš„æ–¹å¼å¦‚ä¸‹ // e[i] : ä»£è¡¨å¦å¤–ä¸€ä¸ªç«¯ç‚¹ // nxt[i] : åŒä¸€ä¸ªé“¾è¡¨ä¸‹çš„ä¸‹ä¸€ä¸ªç´¢å¼• // w[i] : è¾¹é•¿ // h[i] : æŒ‡å‘ç«¯ç‚¹içš„å¤´èŠ‚ç‚¹ // idx : ä¸‹ä¸€æ¡è¾¹çš„ç´¢å¼• int e[M], nxt[M], w[M], h[N], idx; // ä¸€äº›åˆå§‹åŒ– void init() { // åˆšå¼€å§‹æ‰€æœ‰çš„ç‚¹éƒ½æŒ‡å‘ -1 memset(h, -1, sizeof h); } // æ·»åŠ aæŒ‡å‘bä¸”é•¿åº¦ä¸ºcçš„æœ‰å‘è¾¹ void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } // éå† void demo { int cur = 1; for(int i=h[cur];i!=-1;i=nxt[i]) { // å¦å¤–ä¸€è¾¹ int k = e[i]; // .... } } é‚»æ¥çŸ©é˜µ å¯¹äºäºŒç»´æ•°ç»„ g[i][j] è¡¨ç¤ºç‚¹ i æŒ‡å‘ j å­˜åœ¨ g[i][j] é•¿åº¦çš„æœ‰å‘è¾¹ æœ€çŸ­è·¯ç®—æ³• 1. Dijkstra è¿™ä¸ªç®—æ³•é‡‡ç”¨äº†è´ªå¿ƒç­–ç•¥ï¼Œåœ¨æ¯æ¬¡å¯ä»¥éå†å¯ä»¥ç¡®å®šä¸€ä¸ªæœ€ä¼˜ç‚¹ æœ´ç´ çš„Dij å¤æ‚åº¦æ˜¯ O(n2n^2n2)ï¼Œn æ˜¯ç‚¹æ•° æœ´ç´ ç®—æ³•çš„ç“¶é¢ˆåœ¨äºæ‰¾å‡ºå…¨å±€æœ€å°ç‚¹ï¼Œå †ä¼˜åŒ–Dijé‡‡ç”¨æœ€å°å †priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;æ¥å¯¹ dist[i] ç»´æŠ¤ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(mlognmlognmlogn) ï¼Œå…¶ä¸­mæ˜¯è¾¹çš„ä¸ªæ•° ä»£ç æ¨¡æ¿ï¼ˆæœ´ç´ ï¼‰ const int N = 2021; int d[N][N], dist[N]; bool st[N]; // ä½¿ç”¨çš„æ˜¯é‚»æ¥çŸ©é˜µ void dijkstra() { dist[S] = 0; for (int i = 1; i &lt;= n; i++) { int cur = -1; // æ‰¾æœ€å°çš„é‚£ä¸ªï¼ˆå‰ææ˜¯è¿™ä¸ªè¾¹æ²¡æœ‰è¢«æ‰¾è¿‡ï¼‰ for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &gt; dist[j])) cur = j; st[cur] = true; // æ›´æ–°æœ€å°ç‚¹å‘¨å›´çš„è¾¹é•¿ for (int j = 1; j &lt;= n; j++) if (dist[cur] + d[cur][j] &lt; dist[j]) dist[j] = dist[cur] + d[cur][j]; } } ä»£ç æ¨¡æ¿ï¼ˆå †ä¼˜åŒ–ï¼‰ typedef pair&lt;int, int&gt; PII; int dist[N], st[M]; // ä½¿ç”¨çš„æ˜¯é‚»æ¥è¡¨ void dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // å®šä¹‰æœ€å°å † priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; // å¦‚æœæ”¹èŠ‚å·²è¢«ç¡®å®šï¼Œåˆ™æ— éœ€å†è¿›è¡Œç›¸é‚»ç‚¹æ›´æ–° if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } 2. SPFAï¼ˆShortest Path Fast Algorithmï¼‰ è¿™ä¸ªç®—æ³•æ˜¯å¹¿æœçš„å˜å½¢ï¼Œå¾ˆæ˜æ˜¾ï¼Œå½“è·¯å¾„é•¿åº¦ä¸º1çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨BFSæ¥ç®—æœ€çŸ­è·¯ã€‚ è¿™ä¸ªç®—æ³•åœ¨éšæœºå›¾ä¸Šçš„æ—¶é—´å¤æ‚åº¦æ˜¯O(kmkmkm), kæ˜¯ä¸€ä¸ªå¾ˆå°çš„å¸¸æ•°ï¼Œå¯¹äºç‰¹æ®Šå›¾ï¼Œå¯èƒ½ä¼šè¾¾åˆ°O(mnmnmn) çš„æ—¶é—´å¤æ‚åº¦ã€‚ è¿™ä¸ªç®—æ³•æ˜¯å¯ä»¥å¤„ç†è´Ÿæƒè¾¹çš„ ä»£ç æ¨¡æ¿ // èµ·å§‹ç‚¹ S int dist[N], S; bool st[N]; // ä½¿ç”¨çš„æ˜¯é‚»æ¥è¡¨ void spfa() { queue&lt;int&gt; que; que.push(S); dist[u] = 0, st[S] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; // éå†æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹ for (int i = h[cur]; i != -1; i = ne[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; // å¦‚æœä¸åœ¨é˜Ÿåˆ—ä¸­ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ— if (st[k] == 0) que.push(k); } } } } 3. Floydï¼ˆå¤šæºï¼‰ è¿™ä¸ªç®—æ³•å¯ä»¥é€šè¿‡O(n3n^3n3)çš„æ—¶é—´å¤æ‚åº¦ç®—å‡ºä»»æ„ä¸¤ä¸ªç‚¹çš„æœ€çŸ­è·¯ï¼Œæ˜¯ä¸€ç§dpæ€è·¯ã€‚ ä»£ç æ¨¡æ¿ int dist[N][N]; void floyd() { for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } ä¾‹é¢˜è®²è§£ ä¾‹é¢˜ åšæ³•æè¿° ä»£ç  AcWing 1129. çƒ­æµª ç›´æ¥ä¸€éspfaæ—¢å¯ï¼Œä¹Ÿå¯ä»¥ç”¨dijkstra ğŸ”— AcWing 1128. ä¿¡ä½¿ æ•°æ®é‡ä¸å¤§ï¼Œå¯ä»¥ç›´æ¥ä¸€éfloydï¼Œç®—å‡ºè·ç¦»èµ·ç‚¹åˆ°å„ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯é•¿åº¦çš„æœ€å¤§å€¼ ğŸ”— AcWing 1127. é¦™ç”œçš„é»„æ²¹ å¯¹å„èŠ‚ç‚¹è¿›è¡Œä¸€éspfaï¼Œç„¶åå°†å„å¥¶ç‰›åˆ°è¯¥èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ç›¸åŠ å–æœ€å°æ—¢å¯ ğŸ”— AcWing 1126. æœ€å°èŠ±è´¹ ä¹˜æ³•æœ€å¤§å€¼ï¼ˆæƒå€¼å°äº1ï¼‰ï¼Œdijkstraä¿®æ”¹ä¸ºä¹˜æ³•çš„æœ€çŸ­è·¯ï¼Œå¯ä»¥ç”¨logæ¥è¯æ˜å…¶ä½¿ç”¨æœ€çŸ­è·¯ ğŸ”— AcWing 920. æœ€ä¼˜ä¹˜è½¦ æœ€å°æ¢ä¹˜ï¼Œå°†å•ç¨‹é“¾ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å‰é©±éƒ½æŒ‡å‘è¯¥èŠ‚ç‚¹ï¼Œå˜æˆäº†æœ€çŸ­è·¯é—®é¢˜ï¼Œç­”æ¡ˆå°±æ˜¯æœ€çŸ­è·¯é•¿åº¦ - 1 ğŸ”— AcWing 903. æ˜‚è´µçš„è˜ç¤¼ å»ºç«‹ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼Œ æ³¨æ„æ‰€æœ‰äº¤æ˜“é“¾è·¯çš„ç­‰çº§æœ€å°å€¼å’Œæœ€å¤§å€¼ä¸èƒ½è¶…è¿‡Mï¼Œç”¨æœ´ç´ dijæš´åŠ›æ‰€æœ‰ç­‰çº§åŒºé—´æ—¢å¯ ğŸ”— AcWing 1135. æ–°å¹´å¥½ spfaä¼šè¢«å¡ï¼Œç”¨å †ä¼˜åŒ–çš„dijè¿‡çš„ï¼Œä¸»è¦å°±æ˜¯æ±‚å‡º1ã€aã€bã€cã€dã€eç‚¹å„è‡ªçš„æœ€çŸ­è·¯ï¼Œç„¶åéå†è·¯çº¿å³å¯ ğŸ”— AcWing 1129. çƒ­æµª #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; const int N = 2510, M = 6210 &lt;&lt; 1; int start, en, n, m; int e[M], nxt[M], w[M], h[N], idx; int dist[N], st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } void spfa(int u) { queue&lt;int&gt; que; que.push(u); dist[u] = 0, st[u] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; for (int i = h[cur]; i != -1; i = nxt[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; if (st[k] == 0) que.push(k); } } } } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; en; memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= m; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c), add(b, a, c); } spfa(start); cout &lt;&lt; dist[en] &lt;&lt; endl; return 0; } AcWing 1128. ä¿¡ä½¿ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m; const int N = 110, INF = 0x3f3f3f3f; int dist[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= n; i++) dist[i][i] = 0; for (int i = 1; i &lt;= m; i++) { int p1, p2, dis; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis; dist[p1][p2] = dist[p2][p1] = min(dist[p1][p2], dis); } for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); int ans = -1; for (int i = 1; i &lt;= n; i++) { if (dist[1][i] == INF) { ans = -1; break; } ans = max(ans, dist[1][i]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1127. é¦™ç”œçš„é»„æ²¹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, p, c; const int N = 810, M = 510, T = 1510 * 2, INF = 0x3f3f3f3f; int r[N], dist[T]; bool st[T]; int ne[T], w[T], e[T], h[N], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void spfa(int S) { memset(st, 0, sizeof st); memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; que.push(S); dist[S] = 0; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (dist[u] + w[i] &lt; dist[j]) { dist[j] = dist[u] + w[i]; if (!st[j]) que.push(j), st[j] = true; } } } } int main() { cin &gt;&gt; n &gt;&gt; p &gt;&gt; c; memset(h, -1, sizeof h); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; r[i]; for (int i = 1; i &lt;= c; i++) { int a, b, wi; cin &gt;&gt; a &gt;&gt; b &gt;&gt; wi; add(a, b, wi), add(b, a, wi); } int ans = INF; for (int i = 1; i &lt;= p; i++) { spfa(i); int sum = 0, j = 1; for (; j &lt;= n; j++) { if (dist[r[j]] == INF) break; sum += dist[r[j]]; } if (j &lt;= n) continue; ans = min(ans, sum); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1126. æœ€å°èŠ±è´¹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m, S, T; const int N = 2010, INF = 0x3f3f3f3f; double d[N][N], dist[N]; bool st[N]; double dijkstra() { dist[S] = 1.0; for (int i = 1; i &lt;= n; i++) { int cur = -1; for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &lt; dist[j])) cur = j; st[cur] = true; for (int j = 1; j &lt;= n; j++) if (dist[cur] * d[cur][j] &gt; dist[j]) dist[j] = dist[cur] * d[cur][j]; } return dist[T]; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; N; i++) d[i][i] = 1; for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); d[x][y] = d[y][x] = (100.0 - z * 1.0) / 100.0; } cin &gt;&gt; S &gt;&gt; T; printf(&quot;%.8lf\\n&quot;, 100.0 / dijkstra()); return 0; } AcWing 920. æœ€ä¼˜ä¹˜è½¦ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;sstream&gt; #include &lt;queue&gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int g[N][N], dist[N], stop[N]; bool st[N]; int n, m; void spfa() { memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; dist[1] = 0; que.push(1); st[1] = true; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = 1; i &lt;= n; i++) { if (g[u][i] + dist[u] &lt; dist[i]) { dist[i] = g[u][i] + dist[u]; if (!st[i]) que.push(i); } } } } int main() { memset(g, 0x3f, sizeof g); for (int i = 0; i &lt; N; i++) g[i][i] = 0; cin &gt;&gt; m &gt;&gt; n; string line; getline(cin, line); while (m--) { getline(cin, line); stringstream ssin(line); int cnt = 0, p; while (ssin &gt;&gt; p) stop[cnt++] = p; for (int i = 0; i &lt; cnt; i++) for (int j = i + 1; j &lt; cnt; j++) g[stop[i]][stop[j]] = 1; } spfa(); if (dist[n] == INF) puts(&quot;NO&quot;); else cout &lt;&lt; max(0, dist[n] - 1) &lt;&lt; endl; return 0; } AcWing 903. æ˜‚è´µçš„è˜ç¤¼ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, m; int P, L, X; int T, V; const int N = 110, M = 110 * 110; struct Item { int id, p, l; }; unordered_map&lt;int, Item&gt; i2i; unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; mp; int ne[M], w[M], h[N], e[M], idx; int dist[N], st[M]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } typedef pair&lt;int, int&gt; PII; void dijkstra() // æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯è·ç¦» { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } void dijkstra(int l, int r) { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); dist[n + 1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, n + 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (i2i[j].l &lt; l || i2i[j].l &gt; r) continue; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;P, &amp;L, &amp;X); Item item = {i, P, L}; for (int j = 1; j &lt;= X; j++) { scanf(&quot;%d%d&quot;, &amp;T, &amp;V); mp[T][i] = V; } i2i[i] = item; } // å»ºè¾¹ for (auto[k, v] : mp) { for (auto[k1, v1] : v) { if (abs(i2i[k1].l - i2i[k].l) &lt;= m) { add(k, k1, v1); } } } // è™šæ‹ŸèŠ‚ç‚¹ for (int i = 1; i &lt;= n; i++) add(n + 1, i, i2i[i].p); int ans = 0x3f3f3f3f; int le = i2i[1].l; for (int i = le - m; i &lt;= le; i++) { dijkstra(i, i + m); ans = min(ans, dist[1]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1135. æ–°å¹´å¥½ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;map&gt; using namespace std; const int N = 50010, M = 2e5 + 10, INF = 0x3f3f3f3f; int n, m, a, b, c, d, f; int ne[M], w[M], h[N], e[M], idx; int dist[6][N]; bool st[N]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } // void spfa(int distIdx, int S) { // auto &amp;dis = dist[distIdx]; // memset(st, 0, sizeof st); // memset(dis, 0x3f, sizeof dis); // queue&lt;int&gt; que; // que.push(S); // dis[S] = 0; // while(!que.empty()) { // int t = que.front(); // que.pop(); // st[t] = false; // for(int i=h[t];~i;i=ne[i]) { // int j = e[i]; // if(dis[t] + w[i] &lt; dis[j]) { // dis[j] = dis[t] + w[i]; // if(!st[j]) que.push(j), st[j] = true; // } // } // } // } typedef pair&lt;int, int&gt; PII; void dijkstra(int distIdx, int S) // æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯è·ç¦» { auto &amp;dis = dist[distIdx]; memset(dis, 0x3f, sizeof dis); memset(st, 0, sizeof st); dis[S] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, S}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dis[j] &gt; dis[ver] + w[i]) { dis[j] = dis[ver] + w[i]; heap.push({dis[j], j}); } } } } int main() { cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; f; memset(h, -1, sizeof h); for(int i=1;i&lt;=m;i++) { int a1, b1, c1; scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;b1, &amp;c1); add(a1, b1, c1), add(b1, a1, c1); } dijkstra(0, 1); dijkstra(1, a); dijkstra(2, b); dijkstra(3, c); dijkstra(4, d); dijkstra(5, f); vector&lt;int&gt; nums = {a, b, c, d, f}; sort(nums.begin(), nums.end()); unordered_map&lt;int, int&gt; mp; mp[a] = 1, mp[b] = 2, mp[c] = 3, mp[d] = 4, mp[f] = 5; int ans = INF; do { int t = dist[0][nums[0]]; for(int i=0;i&lt;4;i++) { t += dist[mp[nums[i]]][nums[i+1]]; } ans = min(ans, t); } while(next_permutation(nums.begin(), nums.end())); cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/tu-lun-dan-yuan-zui-duan-lu/"},{"title":"ã€DPã€‘æ•°ä½DP","content":" ç®—æ³•ä»‹ç» è¿™æ˜¯ä¸€ç±»å½¢å¼æ¯”è¾ƒå›ºå®šçš„DPé—®é¢˜ï¼Œå¾€å¾€æ˜¯æ±‚åœ¨æŸä¸ªåŒºé—´ [A, B] ä¸­æ»¡è¶³ç‰¹å®šæ¡ä»¶æ•°çš„ä¸ªæ•°ã€‚åšæ³•åŸºæœ¬ä¸Šæ˜¯ä¸‹é¢çš„ä¸€å¥—æ¨¡æ¿ã€‚ // è®¡ç®— 0 - x å†…æœ‰å¤šå°‘æ»¡è¶³æ¡ä»¶çš„æ•° int dp(int x) { // 0 ç‰¹åˆ¤ if(!x) return 0; // è®°å½•æ•°å­—xçš„å„ä½ä¸Šçš„æ•°å­— vector&lt;int&gt; nums; // B ä¸ºå¯¹åº”è¿›åˆ¶ï¼Œé€šå¸¸æ˜¯10è¿›åˆ¶ä¸‹çš„é—®é¢˜ while(x) nums.push_back(x % B), x /= B; // æœ€ç»ˆç­”æ¡ˆ int res = 0; // ä¸Šä¸€ä½æ•°çš„çŠ¶æ€ int last = 0; for(int i=nums.size()-1;i&gt;=0;i--) { int t = nums[i]; // do sth. if(!i) { // do sth. } } return res; } é€šå¸¸ï¼Œå¯¹äº i ä½ä¸Šçš„æ•°å­— k , [0, k-1ä¸Šçš„çŠ¶æ€æˆ‘ä»¬å¯ä»¥é€šè¿‡è¯¸å¦‚åŒºé—´DPæ–¹å¼æ±‚å‡ºæ¥ã€‚ ä¾‹é¢˜è®²è§£ ä¾‹é¢˜ åšæ³•æè¿° ä»£ç  AcWing 1081. åº¦çš„æ•°é‡ ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1082. æ•°å­—æ¸¸æˆ ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1083. Windyæ•° ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1084. æ•°å­—æ¸¸æˆ II ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1085. ä¸è¦62 ç›´æ¥çœ‹ä»£ç  ğŸ”— AcWing 1081. åº¦çš„æ•°é‡ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 32; LL f[N][N]; int X, Y, K, B; int dp(int x) { if (!x) return 0; vector&lt;int&gt; nums; while (x) nums.push_back(x % B), x /= B; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; if (t != 0) { if (t &gt; 1) { res += f[i + 1][K - last]; break; } else { res += f[i][K - last]; last++; if (last &gt; K) break; } } if (!i &amp;&amp; last == K) res++; } return res; } int main() { for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt;= i; j++) { if (j == 0) f[i][j] = 1; else f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; } } cin &gt;&gt; X &gt;&gt; Y &gt;&gt; K &gt;&gt; B; cout &lt;&lt; dp(Y) - dp(X - 1) &lt;&lt; endl; return 0; } ####AcWing 1082. æ•°å­—æ¸¸æˆ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1; else { for (int j = i; j &lt;= 9; j++) { f[i][len] += f[j][len - 1]; } } } } } int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if (last &gt; k) break; for (int j = last; j &lt; k; j++) { res += f[j][i + 1]; } last = k; if (!i) res++; } return res; } int main() { init(); // cout &lt;&lt; f[2][2] &lt;&lt; endl; while (cin &gt;&gt; a &gt;&gt; b) { cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } AcWing 1083. Windyæ•° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N], g[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1, g[i][len] = 1; else { for (int j = 0; j &lt;= 9; j++) { if (abs(j - i) &gt;= 2) { f[i][len] += f[j][len - 1]; } } if (i == 0) { for (int j = 0; j &lt;= 9; j++) { g[0][len] += g[j][len - 1]; } } else { g[i][len] = f[i][len]; } } } } } int dp(int x) { if (x &gt;= 0 &amp;&amp; x &lt;= 9) return x + 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = -2; bool flag = false; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if(k != 0) { if (!flag) { res += g[0][i + 1]; } else if (abs(last) &gt;= 2) { res += f[0][i + 1]; } for (int j = 1; j &lt; k; j++) { if (abs(last - j) &gt;= 2) { res += f[j][i + 1]; } } } if (abs(last - k) &lt;= 1) break; last = k; if (k != 0) flag = true; if (!i) res++; } return res; } int main() { init(); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; return 0; } ####AcWing 1084. æ•°å­—æ¸¸æˆ II #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N][105]; int mod; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) { f[i][len][i % mod] = 1; continue; } for (int j = 0; j &lt; mod; j++) { for (int k = 0; k &lt;= 9; k++) { f[i][len][j] += f[k][len - 1][((j - i) % mod + mod) % mod]; } } } } } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; for (int j = 0; j &lt; k; j++) { res += f[j][i + 1][((mod - last) % mod + mod) % mod]; } last = (last + k) % mod; if (!n &amp;&amp; last % mod == 0) res++; } return res; } int main() { while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod) { memset(f, 0, sizeof(f)); init(); cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } ####AcWing 1085. ä¸è¦62 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (i == 4) continue; if (len == 1) f[i][len] = 1; else { if (i == 6) for (int j = 0; j &lt;= 9; j++) { if (j == 2 || j== 4) continue; f[i][len] += f[j][len - 1]; } else { for (int j = 0; j &lt;= 9; j++) { if(j == 4) continue; f[i][len] += f[j][len - 1]; } } } } } } int n, m; int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int last = 0, res = 0; // res += f[0][nums.size()]; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; for (int j = 0; j &lt; t; j++) { // if(i == nums.size() - 1&amp;&amp; j == 0) continue; if(last == 6 &amp;&amp; j == 2) continue; if(j == 4) continue; res += f[j][i+1]; } if(t == 4) break; if(last == 6 &amp;&amp; t == 2) break; last = t; if(!i) res++; } return res; } int main() { init(); while (cin &gt;&gt; n &gt;&gt; m, !(n == 0 &amp;&amp; m == 0)) { cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; endl; } return 0; } ","link":"https://tofindmore.github.io/post/dp-shu-wei-dp/"},{"title":"ã€DPã€‘çŠ¶æ€å‹ç¼©","content":" ç®—æ³•ä»‹ç» è¿™æ˜¯ä¸€ç±»æŠŠé›†åˆè½¬åŒ–ä¸ºæ•´æ•°è®°å½•åœ¨DPçŠ¶æ€ä¸­çš„ç®—æ³•ã€‚å‡è®¾ 1 ä»£è¡¨æŒæœ‰æŸç§çŠ¶æ€ï¼Œé‚£ä¹ˆå¯¹äºåè¿›åˆ¶æ•° (11)D = (1011)B æ¥è¯´å¯ä»¥è¡¨ç¤ºä¸ºæŒæœ‰ç¬¬ 4 2 1 3ç§çŠ¶æ€ã€‚ å¦‚ä¸‹æ˜¯ num æ‰€æŒæœ‰çš„çŠ¶æ€çš„æ‰€æœ‰å­é›†ï¼ˆåŒ…å«ç©ºé›†ï¼‰ã€‚ int sub = num; do { // do sth sub = num &amp; (sub - 1); } while(sub != num) é€šè¿‡å­é›†é¢„å¤„ç†ï¼Œå¯ä»¥å‡å°‘æšä¸¾çŠ¶æ€å’Œä¸€ç³»åˆ—å¤šä½™çŠ¶æ€çš„åˆ¤æ–­ ä¾‹é¢˜è®²è§£ 1. æ£‹ç›˜ç±»é—®é¢˜ï¼ˆåŸºäºè¿é€šæ€§çš„DPï¼‰ æ£‹ç›˜ç±»é—®é¢˜éœ€è¦æƒ³æ¸…æ¥šå±‚ä¸å±‚ä¹‹é—´çš„çŠ¶æ€è½¬ç§»å…³ç³»ï¼Œé€šå¸¸æ˜¯ä»¥ dp[i][s1] ï½ dp[i-1][s2] è¡¨ç¤ºç¬¬ i å±‚çŠ¶æ€ s1 æ˜¯ç”± i-1 å±‚çŠ¶æ€è½¬ç§»è€Œæ¥ï¼Œæœ‰æ—¶ä¼šç‰µæ‰¯åˆ°ä¸‰å±‚ä¹‹é—´çš„å…³ç³»ï¼Œå³ dp[i][s1] ï½ dp[i-1][s2] and dp[i-2][s3] æœ¬ç«™ç›¸å…³ä¾‹é¢˜è®²è§£ ä¾‹é¢˜ åšæ³•æè¿° ä»£ç  AcWing 1064. å°å›½ç‹ dp[i][j][k]è¡¨ç¤ºç¬¬iè¡ŒçŠ¶æ€ä¸ºkä¸”å‰iè¡Œå…±å¯ä»¥æ”¾jä¸ªå›½ç‹ ğŸ”— AcWing 327. ç‰ç±³ç”° dp[i][s] è¡¨ç¤ºç¬¬iå±‚å‹ç¼©çŠ¶æ€ä½sçš„æ€»ç§æ³• ğŸ”— AcWing 292. ç‚®å…µé˜µåœ° æ»šåŠ¨æ•°ç»„ + dp[i][j][k]è¡¨ç¤ºç¬¬iå±‚çŠ¶æ€jï¼Œi-1å±‚çŠ¶æ€ä¸ºk ğŸ”— 2. é›†åˆç±»é—®é¢˜ // TODO AcWing 1064. å°å›½ç‹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; int n, m; vector&lt;int&gt; stateVec, head[2000]; LL dp[12][110][2000]; int cnt[2000]; bool check(int state) { for (int i = 0; i &lt; n; i++) { if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int count(int state) { int cnt = 0; for (int i = 0; i &lt; n; i++) if (state &gt;&gt; i &amp; 1) ++cnt; return cnt; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) if (check(i)) stateVec.push_back(i), cnt[i] = count(i); for (int i = 0; i &lt; stateVec.size(); i++) { for (int j = 0; j &lt; stateVec.size(); j++) { int a = stateVec[i], b = stateVec[j]; if (!(a &amp; b) &amp;&amp; check(a | b)) { head[a].push_back(b); } } } dp[0][0][0] = 1; for (int i = 1; i &lt;= n + 1; i++) { for (int j = 0; j &lt;= m; j++) { for (int k = 0; k &lt; stateVec.size(); k++) { int a = stateVec[k]; for (int t = 0; t &lt; head[a].size(); t++) { int c = cnt[a]; if (j &gt;= c) dp[i][j][a] += dp[i - 1][j - c][head[a][t]]; } } } } cout &lt;&lt; dp[n + 1][m][0] &lt;&lt; endl; return 0; } AcWing 327. ç‰ç±³ç”° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1 &lt;&lt; 13 + 10; const int M = 14, MOD = 1e8; int n, m, t; int id[M]; long long dp[M][N]; bool check(int s) { for (int i = 0; i &lt; m; i++) { if ((s &gt;&gt; i &amp; 1) &amp;&amp; (s &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; t; id[i] = (id[i] &lt;&lt; 1) + t; } } dp[0][0] = 1; long long ans = 0; for (int i = 1; i &lt;= n; i++) { int pre = id[i - 1], cur = id[i]; int s1 = cur; do { int s2 = pre; do { if (check(s1) &amp;&amp; check(s2) &amp;&amp; (s1 &amp; s2) == 0) { dp[i][s1] = (dp[i][s1] + dp[i - 1][s2]) % MOD; } s2 = (s2 - 1) &amp; pre; } while (s2 != pre); if (i == n) ans = (ans + dp[i][s1]) % MOD; s1 = (s1 - 1) &amp; cur; } while (s1 != cur); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 292. ç‚®å…µé˜µåœ° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 110; const int M = 1 &lt;&lt; 10; int n, m; vector&lt;int&gt; id(N); int dp[2][M][M]; bool check(int s) { for (int i = 0; i &lt; m; i++) { int t = ((s &gt;&gt; i) &amp; 1) + ((s &gt;&gt; (i + 1)) &amp; 1) + ((s &gt;&gt; (i + 2)) &amp; 1); if (t &gt;= 2) return false; } return true; } int count(int s) { int ret = 0; for (int i = 0; i &lt;= m; i++) { if (s &gt;&gt; i &amp; 1) ret++; } return ret; } int main() { cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; head[N]; head[0].push_back(0); head[1].push_back(0); for (int i = 2; i &lt;= n + 1; i++) { for (int j = 0; j &lt; m; j++) { char c; cin &gt;&gt; c; id[i] = (id[i] &lt;&lt; 1) + (c == 'P'); } int s = id[i]; do { if (check(s)) head[i].push_back(s); s = (s - 1) &amp; id[i]; } while (s != id[i]); } int turn = 1; int ans = 0; for (int i = 2; i &lt;= n + 1; i++) { turn ^= 1; for (int j = 0; j &lt; head[i].size(); j++) { for (int k = 0; k &lt; head[i - 1].size(); k++) { for (int v = 0; v &lt; head[i - 2].size(); v++) { int c = head[i][j], p = head[i - 1][k], pp = head[i - 2][v]; if (((c &amp; p) == 0) &amp;&amp; ((pp &amp; p) == 0) &amp;&amp; ((pp &amp; c) == 0)) { dp[turn][c][p] = max(dp[turn ^ 1][p][pp] + count(c), dp[turn][c][p]); ans = max(ans, dp[turn][c][p]); } } } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/dp-zhuan-ti-zhuang-tai-ya-suo/"}]}