{"posts":[{"title":"【图论】单源最短路","content":" 图的存储 对于有向图而言，有两种方式的图存储方式 邻接表 对于邻接表而言，推荐采用链式前向星数组的形式， 增加节点和便利节点的方式如下 // e[i] : 代表另外一个端点 // nxt[i] : 同一个链表下的下一个索引 // w[i] : 边长 // h[i] : 指向端点i的头节点 // idx : 下一条边的索引 int e[M], nxt[M], w[M], h[N], idx; // 一些初始化 void init() { // 刚开始所有的点都指向 -1 memset(h, -1, sizeof h); } // 添加a指向b且长度为c的有向边 void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } // 遍历 void demo { int cur = 1; for(int i=h[cur];i!=-1;i=nxt[i]) { // 另外一边 int k = e[i]; // .... } } 邻接矩阵 对于二维数组 g[i][j] 表示点 i 指向 j 存在 g[i][j] 长度的有向边 最短路算法 1. Dijkstra 这个算法采用了贪心策略，在每次可以遍历可以确定一个最优点 朴素的Dij 复杂度是 O(n2n^2n2)，n 是点数 朴素算法的瓶颈在于找出全局最小点，堆优化Dij采用最小堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;来对 dist[i] 维护，时间复杂度是 O(mlognmlognmlogn) ，其中m是边的个数 代码模板（朴素） const int N = 2021; int d[N][N], dist[N]; bool st[N]; // 使用的是邻接矩阵 void dijkstra() { dist[S] = 0; for (int i = 1; i &lt;= n; i++) { int cur = -1; // 找最小的那个（前提是这个边没有被找过） for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &gt; dist[j])) cur = j; st[cur] = true; // 更新最小点周围的边长 for (int j = 1; j &lt;= n; j++) if (dist[cur] + d[cur][j] &lt; dist[j]) dist[j] = dist[cur] + d[cur][j]; } } 代码模板（堆优化） typedef pair&lt;int, int&gt; PII; int dist[N], st[M]; // 使用的是邻接表 void dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } 2. SPFA（Shortest Path Fast Algorithm） 这个算法是广搜的变形，很明显，当路径长度为1的时候，我们可以用BFS来算最短路。 这个算法在随机图上的时间复杂度是O(kmkmkm), k是一个很小的常数，对于特殊图，可能会达到O(​mnmnmn) 的时间复杂度。 代码模板 // 起始点 S int dist[N], S; bool st[N]; void spfa() { queue&lt;int&gt; que; que.push(S); dist[u] = 0, st[S] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; for (int i = h[cur]; i != -1; i = ne[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; if (st[k] == 0) que.push(k); } } } } 3. Floyd 这个算法可以通过O(n3n^3n3)的时间复杂度算出任意两个点的最短路，其实是一种dp思路。 代码模板 int dist[N][N]; void floyd() { for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } 例题讲解 ","link":"https://tofindmore.github.io/post/tu-lun-dan-yuan-zui-duan-lu/"},{"title":"【DP】状态压缩","content":"算法介绍 这是一类把集合转化为整数记录在DP状态中的算法。假设 1 代表持有某种状态，那么对于十进制数 (11)D = (1011)B 来说可以表示为持有第 4 2 1 3种状态。 如下是 num 所持有的状态的所有子集（包含空集）。 int sub = num; do { // do sth sub = num &amp; (sub - 1); } while(sub != num) 通过子集预处理，可以减少枚举状态和一系列多余状态的判断 例题讲解 1. 棋盘类问题 棋盘类问题需要想清楚层与层之间的状态转移关系，通常是以 dp[i][s1] ～ dp[i-1][s2] 表示第 i 层状态 s1 是由 i-1 层状态转移而来，有时会牵扯到三层之间的关系，即 dp[i][s1] ～ dp[i-1][s2] and dp[i-2][s3] 本站相关例题讲解 玉米田 小国王 ","link":"https://tofindmore.github.io/post/dp-zhuan-ti-zhuang-tai-ya-suo/"}]}