{"posts":[{"title":"【数学知识】 一、质数与约数","content":"质数 试除法，判定n是否是质数，时间复杂度 O(N*SQRT(N)) // 就是一个2到sqrt(n)的遍历 bool isPrime(int n) { if (n &lt;= 1) return false; for (int i = 2; i &lt;= n / i; i++) if (n % i == 0) return false; return true; } 线性筛法 int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 // 线性筛的原理是基于埃式筛，避免重复筛的情况，定义一个合数一定是被其最小质因子筛去的 void getPrimes(int n) { for (int i = 2; i &lt;= n; i++) { if (!st[i]) primes[cnt++] = i; // （1）. 如果 i % primes[j] == 0， 那么 primes[j] 一定是 i 最小质因子 // （2）. 在 （1） 没有发生的时候，primes[j] * i 的最小质因子一定是 primes[j]，此时 i 还没找到自己的最小质因子 // （3）所有合数都有自己的最小质因子，所以一定会被筛 for (int j = 0; primes[j] &lt;= n / i; j++) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 分解质因数 分解质因数 void divide(int n) { for (int i = 2; i &lt;= n / i; i++) { if (n % i == 0) { // 此时 i 一定是质数 int cnt = 0; while (n % i == 0) { cnt++; n /= i; } // 有 cnt 个 i printf(&quot;%d %d\\n&quot;, i, cnt); } } // 大于 sqrt(n) 的数 if (n &gt; 1) printf(&quot;%d 1\\n&quot;, n); puts(&quot;&quot;); } 约数 基本定理：任何一个大于 11 的自然数 NN ，如果 N 不为质数，那么 N 可以唯一分解成有限个质数的乘积 N=P1a1P2a2P3a3......PnanN=P^{a_1}_1P^{a_2}_2P^{a_3}_3......P^{a_n}_nN=P1a1​​P2a2​​P3a3​​......Pnan​​，这里 P1&lt;P2&lt;P3......&lt;PnP_1&lt;P_2&lt;P_3......&lt;P_nP1​&lt;P2​&lt;P3​......&lt;Pn​ 均为质数，其中指数 aiaiai 是正整数。 约数个数：(a1+1)∗(a2+1)∗...∗(an+1)(a_1 + 1) * (a_2 + 1)* ... * (a_n + 1)(a1​+1)∗(a2​+1)∗...∗(an​+1) 约数之和：(P10+P12+…+P1a1)∗…∗(Pn0+Pn2+…+Pna1)(P_{1}^{0}+P_{1}^{2}+…+P_{1}^{a1})∗…∗(P_{n}^{0}+P_{n}^{2}+…+P_{n}^{a1})(P10​+P12​+…+P1a1​)∗…∗(Pn0​+Pn2​+…+Pna1​) // n 个正整数 ai, 请你输出这些数的乘积的约数个数 #include &lt;iostream&gt; #include &lt;unordered_map&gt; using namespace std; const int m = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n--) { int k; cin &gt;&gt; k; for (int i = 2; i &lt;= k / i; i++) { while (k % i == 0) { primes[i]++; k /= i; } } if (k &gt; 1) primes[k]++; } long long ans = 1; for (auto[k, v] : primes) ans = ans * (v + 1) % m; cout &lt;&lt; ans &lt;&lt; endl; return 0; } // n 个正整数 ai，请你输出这些数的乘积的约数之和， #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n--) { int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i++) while (x % i == 0) { x /= i; primes[i]++; } if (x &gt; 1) primes[x]++; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b--) t = (t * a + 1) % mod; res = res * t % mod; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 最大公约数 欧几里得算法又称辗转相除法，是指用于计算两个非负整数非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式 gcd(a,b)=gcd(b,aMODb)gcd(a,b) = gcd(b,a MOD b)gcd(a,b)=gcd(b,aMODb)。 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } ","link":"https://tofindmore.github.io/post/shu-xue-zhi-shi-1-zhi-shu-yu-yue-shu/"},{"title":"【数据结构】线段树","content":"1.线段树基本介绍与实现 树状数组是一种基于分治思想的二叉树结构，用于在区间上进行信息统计，与按照二进制位进行区间划分的树状数组相比，线段树更加通用： 线段树每个节点都代表一个区间 线段树具有唯一的根节点，代表的区间是整个统计范围，如 [1,N][1, N][1,N] 线段树的每个叶子节点都代表一个长度为1的元区间 [x,x][x, x][x,x] 对于每个内部节点 [l,r][l, r][l,r]，他的左子节点是 [mid+1,r][mid+1, r][mid+1,r], 其中 mid = (l+r) &gt;&gt; 1 如下图所示，是一颗二叉树视角的线段树，我们要做的就是做好每个节点的统计信息。 线段树查询、更新的时间复杂度是O(logN)，空间复杂度是O(4N)（至于为什么，可以参照上图证明下就可以了），支持区间操作的（区间操作的时候要做懒标记，即 pushdown 操作）。 下面是实现方式 const int N = 2e5 + 10; // 建立结构体，空间是原始数组的4倍 struct Node { int l, r; int val; } tr[N &lt;&lt; 2]; // 由子节点，向上记录统计信息，如本处记录的是左右节点哪个最大 void pushUp(int u) { tr[u].val = max(tr[u &lt;&lt; 1].val, tr[u &lt;&lt; 1 | 1].val); } // l, r作为新建节点的区间信息，u 代表节点下标 void build(int l, int r, int u) { tr[u].l = l, tr[u].r = r; if (l == r) return; int mid = l + r &gt;&gt; 1; build(l, mid, u &lt;&lt; 1); build(mid + 1, r, u &lt;&lt; 1 | 1); } // 单点修改下标 i 位置的值 void modify(int u, int i, int v) { int l = tr[u].l, r = tr[u].r; if (l == r) { tr[u].val = v; return; } // 查找应该更新哪一边 int mid = l + r &gt;&gt; 1; if (i &lt;= mid) modify(u &lt;&lt; 1, i, v); else modify(u &lt;&lt; 1 | 1, i, v); // 递归完之后，更新本节点的值 pushUp(u); } // 查询区间l, r之间的最大数是多少 int query(int l, int r, int u) { // 如果刚好对应，则返回 if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].val; int mid = tr[u].l + tr[u].r &gt;&gt; 1; // 如果整个在左边 if (r &lt;= mid) return query(l, r, u &lt;&lt; 1); // 如果整个在右边 else if (l &gt; mid) return query(l, r, u &lt;&lt; 1 | 1); // 跨越两边 else return max(query(l, mid, u &lt;&lt; 1), query(mid + 1, r, u &lt;&lt; 1 | 1)); } 2. 一些基本使用 【例题1】最大数 给定一个正整数数列 a1,a2,…,ana_1,a_2,…,a_na1​,a2​,…,an​ 每一个数都在 0∼p−1 之间。 可以对这列数进行两种操作： 添加操作：向序列后添加一个数，序列长度变成 n+1； 询问操作：询问这个序列中最后 L 个数中最大的数是多少。 程序运行的最开始，整数序列为空。 一共要对整数序列进行 m 次操作。 写一个程序，读入操作的序列，并输出询问操作的答案。 输入格式 第一行有两个正整数 m,p，意义如题目描述； 接下来 m 行，每一行表示一个操作。 如果该行的内容是 Q L，则表示这个操作是询问序列中最后 LL 个数的最大数是多少； 如果是 A t，则表示向序列后面加一个数，加入的数是 (t+a) mod p。其中，t 是输入的参数，a 是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 a=0）。 第一个操作一定是添加操作。对于询问操作，L&gt;0 且不超过当前序列的长度。 输出格式 对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 LL 个数的最大数。 数据范围 1≤m≤2×1051≤m≤2×10^51≤m≤2×105 1≤p≤2×1091≤p≤2×10^91≤p≤2×109 0≤t&lt;p0≤t&lt;p0≤t&lt;p 输入样例： 10 100 A 97 Q 1 Q 1 A 17 Q 2 A 63 Q 1 Q 1 Q 3 A 99 输出样例： 97 97 97 60 60 97 样例解释 最后的序列是 97,14,60,96 实现代码如下 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 2e5 + 10; struct Node { int l, r; int val; } tr[N &lt;&lt; 2]; void pushUp(int u) { tr[u].val = max(tr[u &lt;&lt; 1].val, tr[u &lt;&lt; 1 | 1].val); } void build(int l, int r, int u) { tr[u].l = l, tr[u].r = r; if (l == r) return; int mid = l + r &gt;&gt; 1; build(l, mid, u &lt;&lt; 1); build(mid + 1, r, u &lt;&lt; 1 | 1); } void modify(int u, int i, int v) { int l = tr[u].l, r = tr[u].r; if (l == r) { tr[u].val = v; return; } int mid = l + r &gt;&gt; 1; if (i &lt;= mid) modify(u &lt;&lt; 1, i, v); else modify(u &lt;&lt; 1 | 1, i, v); pushUp(u); } int query(int l, int r, int u) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].val; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (r &lt;= mid) return query(l, r, u &lt;&lt; 1); else if (l &gt; mid) return query(l, r, u &lt;&lt; 1 | 1); else return max(query(l, mid, u &lt;&lt; 1), query(mid + 1, r, u &lt;&lt; 1 | 1)); } int main() { int m, p, k, n = 0; int last = 0; build(1, N, 1); cin &gt;&gt; m &gt;&gt; p; while (m--) { char op[2]; scanf(&quot;%s%d&quot;, op, &amp;k); if (op[0] == 'Q') { last = query(n - k + 1, n, 1); cout &lt;&lt; last &lt;&lt; endl; } else { modify(1, ++n, (k + last) % p); } } return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-xian-duan-shu/"},{"title":"【数据结构】树状数组","content":"1. 树状数组基本介绍与实现 树状数组是一个动态维护前缀和的数据结构，其利用的是二进制位转化的关系，保证查询和插入的时间复杂度都是O (logN)， 空间复杂度为 O(N)。如下图所示，粉色代表开辟出的空间数组，代表指向的所有块的和。 如果要算出前7（111B）的和，如图可知，只需算出 4(100B)、6(110B)、7(111B) 3处的和即可，根据 7（111B）， 删去其2进制的末尾1即得到 6（110B）, 根据 6（110B）， 删去其2进制的末尾1即得到 4（100B）,使得其具有天然的关系性。（111 -&gt; 110 -&gt; 100） lowbit数组：对于数 x ， 可得到其末尾 1 的值 int lowbit(int x) { return x &amp; (-x); } 证明如下图 下面是实现方式（往往与离散化一起使用） int bit[N]; int lowbit(int x) { return x &amp; (-x); } int query(int x) { int ans = 0; while (x &gt; 0) { ans += bit[x]; x -= lowbit(x); } return ans; } void add(int x, int val) { while (x &lt; N) { bit[x] += val; x += lowbit(x); } } 2. 一些基本使用 【例题】逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 输入: [7,5,6,4] 输出: 5 实现代码如下 #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; const int SIZE = 5e5 + 10; class Solution { int bit[SIZE]; int lowbit(int x) { return x &amp; (-x); } int query(int x) { int ans = 0; while (x &gt; 0) { ans += bit[x]; x -= lowbit(x); } return ans; } void add(int x, int val) { while (x &lt; SIZE) { bit[x] += val; x += lowbit(x); } } unordered_map&lt;int, int&gt; real2idx; public: int reversePairs(vector&lt;int&gt; &amp;nums) { vector&lt;int&gt; copyNum(nums); // 离散化 sort(copyNum.begin(), copyNum.end()); int cnt = 1; for (int num : copyNum) { if (real2idx.count(num)) continue; real2idx[num] = cnt++; } int ans = 0; for (int num : nums) { ans += query(SIZE - 1) - query(real2idx[num]); add(real2idx[num], 1); } return ans; } }; ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-shu-zhuang-shu-zu/"},{"title":"【ZooKeeper】 （一）了解ZooKeeper ","content":" ZooKeeper 是一个分布式协调服务的开源框架。主要用来解决分布式集群中应用系统的一致性的问题。其本质上是一个分布式的小文件存储系统。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中 的节点进行有效管理。从而来维护和监控你存储的数据的状态变化。将通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。 Paxos算法： 虚拟同步技术(virtual synchrony)： 1.1 Zookeeper 基础 znode : 类似于文件系统的层级树状结构 ​ 在这个文件系统里面，是一个主-从结构的示例 ZooKeeper API暴露的方法： create/path data : 创建一个名为 /path 的 znode 节点，并包含数据 data delete/path : 删除 /path 的 znode exist/path : 检查是否存在名为 /path 的节点 setData/path data : 设置名为 /path 的 znode 的数据为 data getData/path : 返回名为 /path 节点的数据信息 getChildren/path : 返回所有 /path 节点的所有子节点列表 ZooKeeper 不允许局部写入或读取znode节点的数据 znode 的不同类型 当新建znode时，还需要指定该节点的类型(mode)，不同的类型 决定了znode节点的行为方式。 持久节点和临时节点 ： 持久的znode，如/path，只能通过调用delete来进行 删除。临时的znode与之相反，当创建该节点的客户端崩溃或关闭了与 ZooKeeper的连接时，这个节点就会被删除。 一个临时znode，在以下两种情况下将会被删除: 1.当创建该znode的客户端的会话因超时或主动关闭而中止时。 2.当某个客户端(不一定是创建者)主动删除该节点时。 有序节点 ： 一个有序znode节 点被分配唯一个单调递增的整数。当创建有序节点时，一个序号会被追加到路径之后。有序znode通过 提供了创建具有唯一名称的znode的简单方式。同时也通过这种方式可以直观地查看znode的创建顺序。 综上，znode一共有4种类型:持久的(persistent)、临时的 (ephemeral)、持久有序的(persistent_sequential)和临时有序的 (ephemeral_sequential)。 监视与通知 ZooKeeper通常以远程服务的方式被访问，如果每次访问znode时， 客户端都需要获得节点中的内容，这样的代价就非常大。因为这样会导致更高的延迟，而且ZooKeeper需要做更多的操作。 为此，基于通知的机制 ： 客户端向ZooKeeper注册需要接收通知的 znode，通过对znode设置监视点(watch)来接收通知。 版本 每一个znode都有一个版本号，它随着每次数据变化而自增。使用版本来阻止并行操作的不一致性。 1.2 Zookeeper 架构 ZooKeeper服务器端运行于两种模式下:独立模式(standalone)和 仲裁模式(quorum)。独立模式几乎与其术语所描述的一样:有一个单独的服务器，ZooKeeper状态无法复制。在仲裁模式下，具有一组 ZooKeeper服务器，我们称为ZooKeeper集合(ZooKeeper ensemble)，它们之前可以进行状态的复制，并同时为服务于客户端的请求。 这里重点介绍下 仲裁模式 ： 在仲裁模式下，ZooKeeper复制集群中的所有服务器的数据树。但如果让一个客户端等待每个服务器完成数据保存后再继续，延迟问题将无法接受。例如有5台机器，必须有3台进行操作确认；4台机器，必须有3台进行操作确认；可以看出，奇数台的性价比高些。 会话 在对ZooKeeper集合执行任何请求前，一个客户端必须先与服务建立会话。会话的概念非常重要，对ZooKeeper的运行也非常关键。客户端提交给ZooKeeper的所有操作均关联在一个会话上。当一个会话因某种原因而中止时，在这个会话期间创建的临时节点将会消失。 客户端通过TCP协议与服务器进行连接并通信， 但当会话无法与当前连接的服务器继续通信时，会话就可能转移到另一个服务器上。会话提供了顺序保障，这就意味着同一个会话中的请求会以FIFO(先进先出)顺序执行 2.3 开始使用ZooKeeper（MAC OS） 首先从官网下载zookeeper压缩包 https://zookeeper.apache.org/releases.html 找到需要下载的包 Apache ZooKeeper 3.7.0 Source Release(asc, sha512) 得到压缩包 apache-zookeeper-3.7.0-bin.tar.gz 进入相应文件夹，解压压缩包 tar -zxvf ./apache-zookeeper-3.7.0-bin.tar.gz 进入解压后的文件目录，修改配置文件，位于conf文件夹下, 重命名为 zoo.cfg 修改 zoo.cfg, 可以修改 DataDir 文件夹位置，用来zookeeper建目录用的 启动 ./bin/zkServer.sh start 上面这个命令是后台运行 如果想在前台运行并输出命令，可以用 ./bin/zkServer.sh start-foreground 暂停 ./bin/zkServer.sh stop 会话建立 ./bin/zkCli.sh 建立节点，删除并退出会话 ","link":"https://tofindmore.github.io/post/zookeeper-zhi-liao-jie-zookeeper/"},{"title":"【数据结构】单调栈 ","content":" 1. 何谓单调栈 单调栈即满足单调性的栈结构。在遇到实际情况时，需要将不需要维护的数据从栈顶弹出，维护队列单调性。 一般的处理代码如下 // 单调递增栈，插入 t while(!stk.empty() &amp;&amp; stk.top() &gt;= t) stk.pop(); stk.push(t); 2. 实际中的问题 P1 单调栈 给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。 // 根据题意，对于某个待插入的数 t 来说，之前所有比 t 大的数， 对于 t 及以后的数来说都是无用的 // 1. Why 对 t 无用? 答： t 要找比 t 小的 // 2. Why 对 t 以后的数？答：如果往前找，找t就好了，比 t 前面且比 t 大的数不需要再比较了 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { int n, t; cin &gt;&gt; n; stack&lt;int&gt; stk; for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;t); while (!stk.empty() &amp;&amp; stk.top() &gt;= t) stk.pop(); if (stk.empty()) cout &lt;&lt; &quot;-1 &quot;; else cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;; stk.push(t); } return 0; } P2 直方图中最大的矩形 如下图所示，直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为 2,1,4,5,1,3,32,1,4,5,1,3,3 的矩形组成的直方图，矩形的宽度都为 11： 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; using namespace std; typedef long long LL; const int N = 1e5 + 10; int l[N], r[N], g[N], n; int main() { while (scanf(&quot;%d&quot;, &amp;n), n) { for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, g + i); g[0] = -1, g[n + 1] = -1; // 初始化数组 l[i], 表示所有下标 i 左边第一个比他小的下标 stack&lt;int&gt; stk; stk.push(0); for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); l[i] = stk.top(); stk.push(i); } while (!stk.empty()) stk.pop(); stk.push(n + 1); // 初始化数组 r[i], 表示所有下标 i 右边第一个比他小的下标 for (int i = n; i &gt;= 1; i--) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); r[i] = stk.top(); stk.push(i); } // 枚举所有以 i 为顶边的情况 LL ans = 0; for (int i = 1; i &lt;= n; i++) { ans = max(ans, (LL) g[i] * (r[i] - l[i] - 1)); } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } P3 城市游戏 求被 F 覆盖的最大矩形面积， 本题就是上一题直接的变形，枚举每一行，就可以看做是一个直方图 R F F F F F F F F F F F R R R F F F F F F F F F F F F F F F #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; using namespace std; typedef long long LL; const int N = 1010; // mp[i][j] 表示第i行第j列方格上方包括自己有多少个F, 相当于上题中的矩形高度！！！ int l[N], r[N], mp[N][N]; int n, m; int solve(int g[]) { g[0] = -1, g[n + 1] = -1; // 初始化数组 l[i], 表示所有下标 i 左边第一个比他小的下标 stack&lt;int&gt; stk; stk.push(0); for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); l[i] = stk.top(); stk.push(i); } while (!stk.empty()) stk.pop(); stk.push(n + 1); // 初始化数组 r[i], 表示所有下标 i 右边第一个比他小的下标 for (int i = n; i &gt;= 1; i--) { while (!stk.empty() &amp;&amp; g[stk.top()] &gt;= g[i]) stk.pop(); r[i] = stk.top(); stk.push(i); } // 枚举所有以 i 为顶边的情况 LL ans = 0; for (int i = 1; i &lt;= n; i++) { ans = max(ans, (LL) g[i] * (r[i] - l[i] - 1)); } return ans; } int main() { cin &gt;&gt; m &gt;&gt; n; char c[3]; int ans = 0; for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { scanf(&quot;%s&quot;, &amp;c); if(c[0] == 'F') mp[i][j] = mp[i-1][j] + 1; } ans = max(ans, solve(mp[i])); } cout &lt;&lt; ans * 3 &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-dan-diao-zhan/"},{"title":"【数据结构】Trie树","content":"1. Trie 树基本介绍与实现 Trie(字典树)是一种用于实现字符串（不一定是字符串，如一个整数的二进制串等）快速检索的多叉树结构。如下图所示，是字符串 &quot;cab&quot;、&quot;cos&quot;、&quot;car&quot;、&quot;cat&quot;、&quot;cate&quot;、&quot;rain&quot; 插入操作。 下面是建树、查找的代码实现 // tr[i][j] 表示下标 i 节点下 j 号子节点的下标， 此处26是仅有小写字母的合集 // idx 是自增的下标 int tr[M][26], idx; // 插入某个字符串 void insert(char *str) { // 初始化为根节点，表示当前节点 int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // 如果子节点不存在，创建一个新节点 if (!tr[p][u]) tr[p][u] = ++idx; // 更新往下迭代 p = tr[p][u]; } } // 查询某个字符串的信息，这里可以统计单词个数、前缀个数等 int query(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // ... p = tr[p][u]; } // 根据题目返回一些信息 return sth; } 2. Trie 的一些基本使用 2.1 【例题】字符串统计 维护一个字符串集合，支持两种操作： I x 向集合中插入一个字符串 x； Q x 询问一个字符串在集合中出现了多少次。 共有 N 个操作，输入的字符串总长度不超过 10510^5105，字符串仅包含小写英文字母。 输入格式 第一行包含整数 N，表示操作数。 接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。 输出格式 对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x 在集合中出现的次数。 每个结果占一行。 数据范围 1≤N≤2∗1041≤N≤2∗10^41≤N≤2∗104 输入样例： 5 I abc Q abc Q ab I ab Q ab 输出样例： 1 0 1 实现代码如下 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int tr[N][26], idx, cnt[N]; char op[2], str[N]; void insert(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!tr[p][u]) tr[p][u] = ++idx; p = tr[p][u]; } cnt[p]++; } int query(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!tr[p][u]) return 0; p = tr[p][u]; } return cnt[p]; } int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { scanf(&quot;%s%s&quot;, op, str); if (op[0] == 'I') insert(str); else cout &lt;&lt; query(str) &lt;&lt; endl; } return 0; } 2.2 【例题】最大异或对 在给定的 N 个整数 $A_1，A_2……A_N $中选出两个进行 xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数 N。 第二行输入 N 个整数 A1～ANA_1～A_NA1​～AN​。 输出格式 输出一个整数表示答案。 数据范围 1≤N≤1051≤N≤10^51≤N≤105 0≤Ai&lt;2310≤A_i&lt;2^{31}0≤Ai​&lt;231 输入样例： 3 1 2 3 输出样例： 3 实现代码如下 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10, M = 31 * N; int tr[M][2], idx, nums[N]; void insert(int x) { int p = 0; for (int i = 30; i &gt;= 0; i--) { int u = x &gt;&gt; i &amp; 1; if (!tr[p][u]) tr[p][u] = ++idx; p = tr[p][u]; } } int query(int x) { int p = 0, ret = 0; for (int i = 30; i &gt;= 0; i--) { int u = x &gt;&gt; i &amp; 1; if (tr[p][u ^ 1]) p = tr[p][u ^ 1], ret += (1 &lt;&lt; i); else p = tr[p][u]; } return ret; } int main() { int n, x; cin &gt;&gt; n; int tot = -1; while (n--) { cin &gt;&gt; x; insert(x); nums[++tot] = x; } int ans = 0; for (int i = 0; i &lt;= tot; i++) { ans = max(ans, query(nums[i])); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-trie-shu-ji-qi-chi-jiu-hua/"},{"title":"【数据结构】并查集","content":"1. 并查集基本介绍与实现 并查集（Disjoint-Set）是一种可以动态维护若干个不重合的集合，并支持合并和查询的数据结构。即有两种基本操作： Get ：查询一个元素属于哪一个集合 Merge ：把两个集合合并成一个大集合 为了防止插入退化，本博客使用的方法是：路径压缩（在find函数中利用传参赋值的方式） 下面是并查集的实现方式 int p[N]; void init() { for(int i=0;i&lt;N;i++) p[i] = i; } // 压缩后，时间复杂度可以认为是O(1) int find(int x) { // 此处进行了路径压缩 if (x != p[x]) p[x] = find(p[x]); return p[x]; } void merge(int x, int y) { int p1 = find(x); int p2 = find(y); // 如果两者不等， 说明不在同一个集合，将两者进行合并操作 if (p1 != p2) p[p1] = p2; } 2. 一些基本使用 【例题】程序自动分析 在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设 x1,x2,x3,…x1,x2,x3,…x1,x2,x3,…代表程序中出现的变量，给定 n 个形如 xi=xjxi=xj 或 xi≠xjx_i≠x_jxi​​=xj​ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。 例如，一个问题中的约束条件为：x1=x2，x2=x3，x3=x4，x1≠x4x1=x2，x2=x3，x3=x4，x1≠x4x1=x2，x2=x3，x3=x4，x1​=x4，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入格式 输入文件的第 1 行包含 1 个正整数 t，表示需要判定的问题个数，注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第 1 行包含 1 个正整数 n，表示该问题中需要被满足的约束条件个数。 接下来 n 行，每行包括 3 个整数 i,j,e，描述 1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 e=1e=1e=1，则该约束条件为 xi=xjx_i=x_jxi​=xj​；若 e=0e=0e=0，则该约束条件为 xi≠xjx_i≠x_jxi​​=xj​。 输出格式 输出文件包括 t 行。 输出文件的第 k 行输出一个字符串 YES 或者 NO，YES 表示输入中的第 kk 个问题判定为可以被满足，NO 表示不可被满足。 数据范围 $1≤n≤10^5 $ 1≤i,j≤1091≤i,j≤10^91≤i,j≤109 输入样例： 2 2 1 2 1 1 2 0 2 1 2 1 2 1 1 输出样例： NO YES 实现代码如下 // 本题要进行离散化处理，此处的离散方式是：排序 -&gt; 去重 -&gt; 二分查找 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int p[2 * N], nums[N * 2], op[N][3], len; int find(int x) { if (x != p[x]) p[x] = find(p[x]); return p[x]; } int getIdx(int x) { return lower_bound(nums, nums + len, x) - nums; } int main() { int T, n; cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; // 初始化操作 for (int i = 0; i &lt; 2 * N; i++) p[i] = i; int a, b, c; int cnt = -1; for (int i = 0; i &lt; n; i++) { scanf(&quot;%d%d%d&quot;, &amp;op[i][0], &amp;op[i][1], &amp;op[i][2]); nums[++cnt] = op[i][0], nums[++cnt] = op[i][1]; } // 离散化 sort(nums, nums + cnt + 1); len = unique(nums, nums + cnt + 1) - nums; // 对于相等的情况，先处理，进行合并 for (int i = 0; i &lt; n; i++) { if (op[i][2]) { int p1 = find(getIdx(op[i][0])); int p2 = find(getIdx(op[i][1])); if (p1 != p2) p[p1] = p2; } } // 对于不相等的情况，如果发现和之前矛盾吗，则输出NO bool flag = false; for (int i = 0; i &lt; n; i++) { if (!op[i][2]) { int p1 = find(getIdx(op[i][0])); int p2 = find(getIdx(op[i][1])); if (p1 == p2) { puts(&quot;NO&quot;), flag = true; break; } } } if (!flag) puts(&quot;YES&quot;); } return 0; } ","link":"https://tofindmore.github.io/post/shu-ju-jie-gou-bing-cha-ji/"},{"title":"【图论】单源最短路","content":" 图的存储 对于有向图而言，有两种方式的图存储方式 邻接表 对于邻接表而言，推荐采用链式前向星数组的形式， 增加节点和便利节点的方式如下 // e[i] : 代表另外一个端点 // nxt[i] : 同一个链表下的下一个索引 // w[i] : 边长 // h[i] : 指向端点i的头节点 // idx : 下一条边的索引 int e[M], nxt[M], w[M], h[N], idx; // 一些初始化 void init() { // 刚开始所有的点都指向 -1 memset(h, -1, sizeof h); } // 添加a指向b且长度为c的有向边 void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } // 遍历 void demo { int cur = 1; for(int i=h[cur];i!=-1;i=nxt[i]) { // 另外一边 int k = e[i]; // .... } } 邻接矩阵 对于二维数组 g[i][j] 表示点 i 指向 j 存在 g[i][j] 长度的有向边 最短路算法 1. Dijkstra 这个算法采用了贪心策略，在每次可以遍历可以确定一个最优点 朴素的Dij 复杂度是 O(n2n^2n2)，n 是点数 朴素算法的瓶颈在于找出全局最小点，堆优化Dij采用最小堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;来对 dist[i] 维护，时间复杂度是 O(mlognmlognmlogn) ，其中m是边的个数 代码模板（朴素） const int N = 2021; int d[N][N], dist[N]; bool st[N]; // 使用的是邻接矩阵 void dijkstra() { dist[S] = 0; for (int i = 1; i &lt;= n; i++) { int cur = -1; // 找最小的那个（前提是这个边没有被找过） for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &gt; dist[j])) cur = j; st[cur] = true; // 更新最小点周围的边长 for (int j = 1; j &lt;= n; j++) if (dist[cur] + d[cur][j] &lt; dist[j]) dist[j] = dist[cur] + d[cur][j]; } } 代码模板（堆优化） typedef pair&lt;int, int&gt; PII; int dist[N], st[M]; // 使用的是邻接表 void dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 定义最小堆 priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; // 如果改节已被确定，则无需再进行相邻点更新 if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } 2. SPFA（Shortest Path Fast Algorithm） 这个算法是广搜的变形，很明显，当路径长度为1的时候，我们可以用BFS来算最短路。 这个算法在随机图上的时间复杂度是O(kmkmkm), k是一个很小的常数，对于特殊图，可能会达到O(mnmnmn) 的时间复杂度。 这个算法是可以处理负权边的 代码模板 // 起始点 S int dist[N], S; bool st[N]; // 使用的是邻接表 void spfa() { queue&lt;int&gt; que; que.push(S); dist[u] = 0, st[S] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; // 遍历所有相邻节点 for (int i = h[cur]; i != -1; i = ne[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; // 如果不在队列中，则加入队列 if (st[k] == 0) que.push(k); } } } } 3. Floyd（多源） 这个算法可以通过O(n3n^3n3)的时间复杂度算出任意两个点的最短路，是一种dp思路。 代码模板 int dist[N][N]; void floyd() { for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } 例题讲解 例题 做法描述 代码 AcWing 1129. 热浪 直接一遍spfa既可，也可以用dijkstra 🔗 AcWing 1128. 信使 数据量不大，可以直接一遍floyd，算出距离起点到各点之间的最短路长度的最大值 🔗 AcWing 1127. 香甜的黄油 对各节点进行一遍spfa，然后将各奶牛到该节点的最短路径相加取最小既可 🔗 AcWing 1126. 最小花费 乘法最大值（权值小于1），dijkstra修改为乘法的最短路，可以用log来证明其使用最短路 🔗 AcWing 920. 最优乘车 最小换乘，将单程链中每个节点的前驱都指向该节点，变成了最短路问题，答案就是最短路长度 - 1 🔗 AcWing 903. 昂贵的聘礼 建立一个虚拟节点， 注意所有交易链路的等级最小值和最大值不能超过M，用朴素dij暴力所有等级区间既可 🔗 AcWing 1135. 新年好 spfa会被卡，用堆优化的dij过的，主要就是求出1、a、b、c、d、e点各自的最短路，然后遍历路线即可 🔗 AcWing 1129. 热浪 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; const int N = 2510, M = 6210 &lt;&lt; 1; int start, en, n, m; int e[M], nxt[M], w[M], h[N], idx; int dist[N], st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, nxt[idx] = h[a], h[a] = idx++; } void spfa(int u) { queue&lt;int&gt; que; que.push(u); dist[u] = 0, st[u] = 1; while (!que.empty()) { int cur = que.front(); que.pop(); st[cur] = 0; for (int i = h[cur]; i != -1; i = nxt[i]) { int k = e[i]; if (dist[cur] + w[i] &lt; dist[k]) { dist[k] = dist[cur] + w[i]; if (st[k] == 0) que.push(k); } } } } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; en; memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= m; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c), add(b, a, c); } spfa(start); cout &lt;&lt; dist[en] &lt;&lt; endl; return 0; } AcWing 1128. 信使 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m; const int N = 110, INF = 0x3f3f3f3f; int dist[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; memset(dist, 0x3f, sizeof dist); for (int i = 1; i &lt;= n; i++) dist[i][i] = 0; for (int i = 1; i &lt;= m; i++) { int p1, p2, dis; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis; dist[p1][p2] = dist[p2][p1] = min(dist[p1][p2], dis); } for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); int ans = -1; for (int i = 1; i &lt;= n; i++) { if (dist[1][i] == INF) { ans = -1; break; } ans = max(ans, dist[1][i]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1127. 香甜的黄油 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, p, c; const int N = 810, M = 510, T = 1510 * 2, INF = 0x3f3f3f3f; int r[N], dist[T]; bool st[T]; int ne[T], w[T], e[T], h[N], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void spfa(int S) { memset(st, 0, sizeof st); memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; que.push(S); dist[S] = 0; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (dist[u] + w[i] &lt; dist[j]) { dist[j] = dist[u] + w[i]; if (!st[j]) que.push(j), st[j] = true; } } } } int main() { cin &gt;&gt; n &gt;&gt; p &gt;&gt; c; memset(h, -1, sizeof h); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; r[i]; for (int i = 1; i &lt;= c; i++) { int a, b, wi; cin &gt;&gt; a &gt;&gt; b &gt;&gt; wi; add(a, b, wi), add(b, a, wi); } int ans = INF; for (int i = 1; i &lt;= p; i++) { spfa(i); int sum = 0, j = 1; for (; j &lt;= n; j++) { if (dist[r[j]] == INF) break; sum += dist[r[j]]; } if (j &lt;= n) continue; ans = min(ans, sum); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1126. 最小花费 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int n, m, S, T; const int N = 2010, INF = 0x3f3f3f3f; double d[N][N], dist[N]; bool st[N]; double dijkstra() { dist[S] = 1.0; for (int i = 1; i &lt;= n; i++) { int cur = -1; for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (cur == -1 || dist[cur] &lt; dist[j])) cur = j; st[cur] = true; for (int j = 1; j &lt;= n; j++) if (dist[cur] * d[cur][j] &gt; dist[j]) dist[j] = dist[cur] * d[cur][j]; } return dist[T]; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; N; i++) d[i][i] = 1; for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); d[x][y] = d[y][x] = (100.0 - z * 1.0) / 100.0; } cin &gt;&gt; S &gt;&gt; T; printf(&quot;%.8lf\\n&quot;, 100.0 / dijkstra()); return 0; } AcWing 920. 最优乘车 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;sstream&gt; #include &lt;queue&gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int g[N][N], dist[N], stop[N]; bool st[N]; int n, m; void spfa() { memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; que; dist[1] = 0; que.push(1); st[1] = true; while (!que.empty()) { int u = que.front(); que.pop(); st[u] = false; for (int i = 1; i &lt;= n; i++) { if (g[u][i] + dist[u] &lt; dist[i]) { dist[i] = g[u][i] + dist[u]; if (!st[i]) que.push(i); } } } } int main() { memset(g, 0x3f, sizeof g); for (int i = 0; i &lt; N; i++) g[i][i] = 0; cin &gt;&gt; m &gt;&gt; n; string line; getline(cin, line); while (m--) { getline(cin, line); stringstream ssin(line); int cnt = 0, p; while (ssin &gt;&gt; p) stop[cnt++] = p; for (int i = 0; i &lt; cnt; i++) for (int j = i + 1; j &lt; cnt; j++) g[stop[i]][stop[j]] = 1; } spfa(); if (dist[n] == INF) puts(&quot;NO&quot;); else cout &lt;&lt; max(0, dist[n] - 1) &lt;&lt; endl; return 0; } AcWing 903. 昂贵的聘礼 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; int n, m; int P, L, X; int T, V; const int N = 110, M = 110 * 110; struct Item { int id, p, l; }; unordered_map&lt;int, Item&gt; i2i; unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; mp; int ne[M], w[M], h[N], e[M], idx; int dist[N], st[M]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } typedef pair&lt;int, int&gt; PII; void dijkstra() // 求1号点到n号点的最短路距离 { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } void dijkstra(int l, int r) { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); dist[n + 1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, n + 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (i2i[j].l &lt; l || i2i[j].l &gt; r) continue; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;P, &amp;L, &amp;X); Item item = {i, P, L}; for (int j = 1; j &lt;= X; j++) { scanf(&quot;%d%d&quot;, &amp;T, &amp;V); mp[T][i] = V; } i2i[i] = item; } // 建边 for (auto[k, v] : mp) { for (auto[k1, v1] : v) { if (abs(i2i[k1].l - i2i[k].l) &lt;= m) { add(k, k1, v1); } } } // 虚拟节点 for (int i = 1; i &lt;= n; i++) add(n + 1, i, i2i[i].p); int ans = 0x3f3f3f3f; int le = i2i[1].l; for (int i = le - m; i &lt;= le; i++) { dijkstra(i, i + m); ans = min(ans, dist[1]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 1135. 新年好 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;map&gt; using namespace std; const int N = 50010, M = 2e5 + 10, INF = 0x3f3f3f3f; int n, m, a, b, c, d, f; int ne[M], w[M], h[N], e[M], idx; int dist[6][N]; bool st[N]; void add(int a, int b, int c) { w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++; } // void spfa(int distIdx, int S) { // auto &amp;dis = dist[distIdx]; // memset(st, 0, sizeof st); // memset(dis, 0x3f, sizeof dis); // queue&lt;int&gt; que; // que.push(S); // dis[S] = 0; // while(!que.empty()) { // int t = que.front(); // que.pop(); // st[t] = false; // for(int i=h[t];~i;i=ne[i]) { // int j = e[i]; // if(dis[t] + w[i] &lt; dis[j]) { // dis[j] = dis[t] + w[i]; // if(!st[j]) que.push(j), st[j] = true; // } // } // } // } typedef pair&lt;int, int&gt; PII; void dijkstra(int distIdx, int S) // 求1号点到n号点的最短路距离 { auto &amp;dis = dist[distIdx]; memset(dis, 0x3f, sizeof dis); memset(st, 0, sizeof st); dis[S] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, S}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dis[j] &gt; dis[ver] + w[i]) { dis[j] = dis[ver] + w[i]; heap.push({dis[j], j}); } } } } int main() { cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; f; memset(h, -1, sizeof h); for(int i=1;i&lt;=m;i++) { int a1, b1, c1; scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;b1, &amp;c1); add(a1, b1, c1), add(b1, a1, c1); } dijkstra(0, 1); dijkstra(1, a); dijkstra(2, b); dijkstra(3, c); dijkstra(4, d); dijkstra(5, f); vector&lt;int&gt; nums = {a, b, c, d, f}; sort(nums.begin(), nums.end()); unordered_map&lt;int, int&gt; mp; mp[a] = 1, mp[b] = 2, mp[c] = 3, mp[d] = 4, mp[f] = 5; int ans = INF; do { int t = dist[0][nums[0]]; for(int i=0;i&lt;4;i++) { t += dist[mp[nums[i]]][nums[i+1]]; } ans = min(ans, t); } while(next_permutation(nums.begin(), nums.end())); cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/tu-lun-dan-yuan-zui-duan-lu/"},{"title":"【DP】数位DP","content":" 算法介绍 这是一类形式比较固定的DP问题，往往是求在某个区间 [A, B] 中满足特定条件数的个数。做法基本上是下面的一套模板。 // 计算 0 - x 内有多少满足条件的数 int dp(int x) { // 0 特判 if(!x) return 0; // 记录数字x的各位上的数字 vector&lt;int&gt; nums; // B 为对应进制，通常是10进制下的问题 while(x) nums.push_back(x % B), x /= B; // 最终答案 int res = 0; // 上一位数的状态 int last = 0; for(int i=nums.size()-1;i&gt;=0;i--) { int t = nums[i]; // do sth. if(!i) { // do sth. } } return res; } 通常，对于 i 位上的数字 k , [0, k-1上的状态我们可以通过诸如区间DP方式求出来。 例题讲解 例题 做法描述 代码 AcWing 1081. 度的数量 直接看代码 🔗 AcWing 1082. 数字游戏 直接看代码 🔗 AcWing 1083. Windy数 直接看代码 🔗 AcWing 1084. 数字游戏 II 直接看代码 🔗 AcWing 1085. 不要62 直接看代码 🔗 AcWing 1081. 度的数量 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 32; LL f[N][N]; int X, Y, K, B; int dp(int x) { if (!x) return 0; vector&lt;int&gt; nums; while (x) nums.push_back(x % B), x /= B; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; if (t != 0) { if (t &gt; 1) { res += f[i + 1][K - last]; break; } else { res += f[i][K - last]; last++; if (last &gt; K) break; } } if (!i &amp;&amp; last == K) res++; } return res; } int main() { for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt;= i; j++) { if (j == 0) f[i][j] = 1; else f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; } } cin &gt;&gt; X &gt;&gt; Y &gt;&gt; K &gt;&gt; B; cout &lt;&lt; dp(Y) - dp(X - 1) &lt;&lt; endl; return 0; } ####AcWing 1082. 数字游戏 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1; else { for (int j = i; j &lt;= 9; j++) { f[i][len] += f[j][len - 1]; } } } } } int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if (last &gt; k) break; for (int j = last; j &lt; k; j++) { res += f[j][i + 1]; } last = k; if (!i) res++; } return res; } int main() { init(); // cout &lt;&lt; f[2][2] &lt;&lt; endl; while (cin &gt;&gt; a &gt;&gt; b) { cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } AcWing 1083. Windy数 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N], g[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) f[i][len] = 1, g[i][len] = 1; else { for (int j = 0; j &lt;= 9; j++) { if (abs(j - i) &gt;= 2) { f[i][len] += f[j][len - 1]; } } if (i == 0) { for (int j = 0; j &lt;= 9; j++) { g[0][len] += g[j][len - 1]; } } else { g[i][len] = f[i][len]; } } } } } int dp(int x) { if (x &gt;= 0 &amp;&amp; x &lt;= 9) return x + 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int res = 0, last = -2; bool flag = false; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; if(k != 0) { if (!flag) { res += g[0][i + 1]; } else if (abs(last) &gt;= 2) { res += f[0][i + 1]; } for (int j = 1; j &lt; k; j++) { if (abs(last - j) &gt;= 2) { res += f[j][i + 1]; } } } if (abs(last - k) &lt;= 1) break; last = k; if (k != 0) flag = true; if (!i) res++; } return res; } int main() { init(); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; return 0; } ####AcWing 1084. 数字游戏 II #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;deque&gt; #include &lt;map&gt; using namespace std; int a, b; const int N = 12; int f[N][N][105]; int mod; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (len == 1) { f[i][len][i % mod] = 1; continue; } for (int j = 0; j &lt; mod; j++) { for (int k = 0; k &lt;= 9; k++) { f[i][len][j] += f[k][len - 1][((j - i) % mod + mod) % mod]; } } } } } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) { int k = nums[i]; for (int j = 0; j &lt; k; j++) { res += f[j][i + 1][((mod - last) % mod + mod) % mod]; } last = (last + k) % mod; if (!n &amp;&amp; last % mod == 0) res++; } return res; } int main() { while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod) { memset(f, 0, sizeof(f)); init(); cout &lt;&lt; dp(b) - dp(a - 1) &lt;&lt; endl; } return 0; } ####AcWing 1085. 不要62 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 12; int f[N][N]; void init() { for (int len = 1; len &lt; N; len++) { for (int i = 0; i &lt;= 9; i++) { if (i == 4) continue; if (len == 1) f[i][len] = 1; else { if (i == 6) for (int j = 0; j &lt;= 9; j++) { if (j == 2 || j== 4) continue; f[i][len] += f[j][len - 1]; } else { for (int j = 0; j &lt;= 9; j++) { if(j == 4) continue; f[i][len] += f[j][len - 1]; } } } } } } int n, m; int dp(int x) { if (!x) return 1; vector&lt;int&gt; nums; while (x) nums.push_back(x % 10), x /= 10; int last = 0, res = 0; // res += f[0][nums.size()]; for (int i = nums.size() - 1; i &gt;= 0; i--) { int t = nums[i]; for (int j = 0; j &lt; t; j++) { // if(i == nums.size() - 1&amp;&amp; j == 0) continue; if(last == 6 &amp;&amp; j == 2) continue; if(j == 4) continue; res += f[j][i+1]; } if(t == 4) break; if(last == 6 &amp;&amp; t == 2) break; last = t; if(!i) res++; } return res; } int main() { init(); while (cin &gt;&gt; n &gt;&gt; m, !(n == 0 &amp;&amp; m == 0)) { cout &lt;&lt; dp(m) - dp(n - 1) &lt;&lt; endl; } return 0; } ","link":"https://tofindmore.github.io/post/dp-shu-wei-dp/"},{"title":"【DP】状态压缩","content":" 算法介绍 这是一类把集合转化为整数记录在DP状态中的算法。假设 1 代表持有某种状态，那么对于十进制数 (11)D = (1011)B 来说可以表示为持有第 4 2 1 3种状态。 如下是 num 所持有的状态的所有子集（包含空集）。 int sub = num; do { // do sth sub = num &amp; (sub - 1); } while(sub != num) 通过子集预处理，可以减少枚举状态和一系列多余状态的判断 例题讲解 1. 棋盘类问题（基于连通性的DP） 棋盘类问题需要想清楚层与层之间的状态转移关系，通常是以 dp[i][s1] ～ dp[i-1][s2] 表示第 i 层状态 s1 是由 i-1 层状态转移而来，有时会牵扯到三层之间的关系，即 dp[i][s1] ～ dp[i-1][s2] and dp[i-2][s3] 本站相关例题讲解 例题 做法描述 代码 AcWing 1064. 小国王 dp[i][j][k]表示第i行状态为k且前i行共可以放j个国王 🔗 AcWing 327. 玉米田 dp[i][s] 表示第i层压缩状态位s的总种法 🔗 AcWing 292. 炮兵阵地 滚动数组 + dp[i][j][k]表示第i层状态j，i-1层状态为k 🔗 2. 集合类问题 // TODO AcWing 1064. 小国王 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; int n, m; vector&lt;int&gt; stateVec, head[2000]; LL dp[12][110][2000]; int cnt[2000]; bool check(int state) { for (int i = 0; i &lt; n; i++) { if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int count(int state) { int cnt = 0; for (int i = 0; i &lt; n; i++) if (state &gt;&gt; i &amp; 1) ++cnt; return cnt; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) if (check(i)) stateVec.push_back(i), cnt[i] = count(i); for (int i = 0; i &lt; stateVec.size(); i++) { for (int j = 0; j &lt; stateVec.size(); j++) { int a = stateVec[i], b = stateVec[j]; if (!(a &amp; b) &amp;&amp; check(a | b)) { head[a].push_back(b); } } } dp[0][0][0] = 1; for (int i = 1; i &lt;= n + 1; i++) { for (int j = 0; j &lt;= m; j++) { for (int k = 0; k &lt; stateVec.size(); k++) { int a = stateVec[k]; for (int t = 0; t &lt; head[a].size(); t++) { int c = cnt[a]; if (j &gt;= c) dp[i][j][a] += dp[i - 1][j - c][head[a][t]]; } } } } cout &lt;&lt; dp[n + 1][m][0] &lt;&lt; endl; return 0; } AcWing 327. 玉米田 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1 &lt;&lt; 13 + 10; const int M = 14, MOD = 1e8; int n, m, t; int id[M]; long long dp[M][N]; bool check(int s) { for (int i = 0; i &lt; m; i++) { if ((s &gt;&gt; i &amp; 1) &amp;&amp; (s &gt;&gt; (i + 1) &amp; 1)) return false; } return true; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; t; id[i] = (id[i] &lt;&lt; 1) + t; } } dp[0][0] = 1; long long ans = 0; for (int i = 1; i &lt;= n; i++) { int pre = id[i - 1], cur = id[i]; int s1 = cur; do { int s2 = pre; do { if (check(s1) &amp;&amp; check(s2) &amp;&amp; (s1 &amp; s2) == 0) { dp[i][s1] = (dp[i][s1] + dp[i - 1][s2]) % MOD; } s2 = (s2 - 1) &amp; pre; } while (s2 != pre); if (i == n) ans = (ans + dp[i][s1]) % MOD; s1 = (s1 - 1) &amp; cur; } while (s1 != cur); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } AcWing 292. 炮兵阵地 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 110; const int M = 1 &lt;&lt; 10; int n, m; vector&lt;int&gt; id(N); int dp[2][M][M]; bool check(int s) { for (int i = 0; i &lt; m; i++) { int t = ((s &gt;&gt; i) &amp; 1) + ((s &gt;&gt; (i + 1)) &amp; 1) + ((s &gt;&gt; (i + 2)) &amp; 1); if (t &gt;= 2) return false; } return true; } int count(int s) { int ret = 0; for (int i = 0; i &lt;= m; i++) { if (s &gt;&gt; i &amp; 1) ret++; } return ret; } int main() { cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; head[N]; head[0].push_back(0); head[1].push_back(0); for (int i = 2; i &lt;= n + 1; i++) { for (int j = 0; j &lt; m; j++) { char c; cin &gt;&gt; c; id[i] = (id[i] &lt;&lt; 1) + (c == 'P'); } int s = id[i]; do { if (check(s)) head[i].push_back(s); s = (s - 1) &amp; id[i]; } while (s != id[i]); } int turn = 1; int ans = 0; for (int i = 2; i &lt;= n + 1; i++) { turn ^= 1; for (int j = 0; j &lt; head[i].size(); j++) { for (int k = 0; k &lt; head[i - 1].size(); k++) { for (int v = 0; v &lt; head[i - 2].size(); v++) { int c = head[i][j], p = head[i - 1][k], pp = head[i - 2][v]; if (((c &amp; p) == 0) &amp;&amp; ((pp &amp; p) == 0) &amp;&amp; ((pp &amp; c) == 0)) { dp[turn][c][p] = max(dp[turn ^ 1][p][pp] + count(c), dp[turn][c][p]); ans = max(ans, dp[turn][c][p]); } } } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://tofindmore.github.io/post/dp-zhuan-ti-zhuang-tai-ya-suo/"}]}